   1               		.file	"random.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__CCP__ = 0x34
   7               	__tmp_reg__ = 0
   8               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  11               		.cfi_sections	.debug_frame
  12               		.section	.text.random_init,"ax",@progbits
  13               	.global	random_init
  15               	random_init:
  16               	.LFB28:
  17               		.file 1 "../src/random.c"
   1:../src/random.c **** #include "random.h"
   2:../src/random.c **** 
   3:../src/random.c **** static uint8_t r_round;
   4:../src/random.c **** static uint8_t r_position;
   5:../src/random.c **** 
   6:../src/random.c **** static uint8_t randNormHasSaved;
   7:../src/random.c **** static float randNormSavedValue;
   8:../src/random.c **** 
   9:../src/random.c **** void random_init(){
  18               		.loc 1 9 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  10:../src/random.c **** 	// Advanced Encryption Standard (AES) crypto module [one of two Onboard Crypto Engines]
  11:../src/random.c **** 
  12:../src/random.c **** 	// Xmega AU Manual, p. 316:
  13:../src/random.c **** 	// The AES crypto module encrypts and decrypts 128-bit data blocks with the use of a 128-bit key.
  14:../src/random.c ****     // The key and data must be loaded into the key and state memory in the module before encryptio
  15:../src/random.c ****     // decryption is started. It takes 375 peripheral clock cycles before the encryption/decryption
  16:../src/random.c ****     // done. The encrypted/encrypted data can then be read out, and an optional interrupt can be ge
  17:../src/random.c ****     // The AES crypto module also has DMA support with transfer triggers when
  18:../src/random.c ****     // encryption/decryption is done and optional auto-start of encryption/decryption when the stat
  19:../src/random.c ****     // memory is fully loaded.
  20:../src/random.c **** 
  21:../src/random.c **** 	// CTRL – Control Register
  22:../src/random.c **** 	// Bit 5 – RESET: Software Reset
  23:../src/random.c ****     // Setting this bit will reset the AES crypto module to its initial status on the next positive
  24:../src/random.c ****     // the peripheral clock. All registers, pointers, and memories in the module are set to their i
  25:../src/random.c ****     // value. When written to one, the bit stays high for one clock cycle before it is reset to zer
  26:../src/random.c ****     // hardware. (p. 320)
  27:../src/random.c **** 
  28:../src/random.c **** 	AES.CTRL = AES_RESET_bm;
  24               		.loc 1 28 0
  25 0000 80E2      		ldi r24,lo8(32)
  26 0002 8093 C000 		sts 192,r24
  29:../src/random.c **** 
  30:../src/random.c ****     // The KEY register is used to access the key memory. Before encryption/decryption can take
  31:../src/random.c ****     // place, the key memory must be written sequentially, byte-by-byte, through the KEY register.
  32:../src/random.c ****     // After encryption/decryption is done, the last subkey can be read sequentially, byte-by-byte,
  33:../src/random.c ****     // through the KEY register.
  34:../src/random.c ****     // Loading the initial data to the KEY register should be done after setting the appropriate AE
  35:../src/random.c ****     // mode and direction. (p. 322)
  36:../src/random.c **** 
  37:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM0;
  27               		.loc 1 37 0
  28 0006 88B1      		in r24,0x8
  29 0008 8093 C300 		sts 195,r24
  38:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM1;
  30               		.loc 1 38 0
  31 000c 89B1      		in r24,0x9
  32 000e 8093 C300 		sts 195,r24
  39:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM2;
  33               		.loc 1 39 0
  34 0012 8AB1      		in r24,0xa
  35 0014 8093 C300 		sts 195,r24
  40:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM3;
  36               		.loc 1 40 0
  37 0018 8BB1      		in r24,0xb
  38 001a 8093 C300 		sts 195,r24
  41:../src/random.c **** 
  42:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM4;
  39               		.loc 1 42 0
  40 001e 8CB1      		in r24,0xc
  41 0020 8093 C300 		sts 195,r24
  43:../src/random.c **** 	AES.KEY = PRODSIGNATURES_LOTNUM5;
  42               		.loc 1 43 0
  43 0024 8DB1      		in r24,0xd
  44 0026 8093 C300 		sts 195,r24
  44:../src/random.c **** 	AES.KEY = PRODSIGNATURES_WAFNUM;
  45               		.loc 1 44 0
  46 002a 80B3      		in r24,0x10
  47 002c 8093 C300 		sts 195,r24
  45:../src/random.c **** 	AES.KEY = PRODSIGNATURES_COORDX0;
  48               		.loc 1 45 0
  49 0030 82B3      		in r24,0x12
  50 0032 8093 C300 		sts 195,r24
  46:../src/random.c **** 
  47:../src/random.c **** 	AES.KEY = PRODSIGNATURES_COORDX1;
  51               		.loc 1 47 0
  52 0036 83B3      		in r24,0x13
  53 0038 8093 C300 		sts 195,r24
  48:../src/random.c **** 	AES.KEY = PRODSIGNATURES_COORDY0;
  54               		.loc 1 48 0
  55 003c 84B3      		in r24,0x14
  56 003e 8093 C300 		sts 195,r24
  49:../src/random.c **** 	AES.KEY = PRODSIGNATURES_COORDY1;
  57               		.loc 1 49 0
  58 0042 85B3      		in r24,0x15
  59 0044 8093 C300 		sts 195,r24
  50:../src/random.c **** 	AES.KEY = ADCA.CH0.RESL;
  60               		.loc 1 50 0
  61 0048 8091 2402 		lds r24,548
  62 004c 8093 C300 		sts 195,r24
  51:../src/random.c **** 
  52:../src/random.c **** 	AES.KEY = ADCA.CH1.RESL;
  63               		.loc 1 52 0
  64 0050 8091 2C02 		lds r24,556
  65 0054 8093 C300 		sts 195,r24
  53:../src/random.c **** 	AES.KEY = ADCA.CH2.RESL;
  66               		.loc 1 53 0
  67 0058 8091 3402 		lds r24,564
  68 005c 8093 C300 		sts 195,r24
  54:../src/random.c **** 	AES.KEY = ADCB.CH0.RESL;
  69               		.loc 1 54 0
  70 0060 8091 6402 		lds r24,612
  71 0064 8093 C300 		sts 195,r24
  55:../src/random.c **** 	AES.KEY = ADCB.CH1.RESL;
  72               		.loc 1 55 0
  73 0068 8091 6C02 		lds r24,620
  74 006c 8093 C300 		sts 195,r24
  56:../src/random.c **** 
  57:../src/random.c **** 	r_round = 1;
  75               		.loc 1 57 0
  76 0070 81E0      		ldi r24,lo8(1)
  77 0072 8093 0000 		sts r_round,r24
  78               	.LVL0:
  79 0076 80E1      		ldi r24,lo8(16)
  80               	.LBB11:
  58:../src/random.c **** 
  59:../src/random.c **** 	// The STATE register is used to access the state memory. Before encryption/decryption can take
  60:../src/random.c ****     // place, the state memory must be written sequentially, byte-by-byte, through the STATE regist
  61:../src/random.c ****     // After encryption/decryption is done, the ciphertext/plaintext can be read sequentially, byte
  62:../src/random.c ****     // through the STATE register.
  63:../src/random.c ****     // Loading the initial data to the STATE register should be done after setting the appropriate 
  64:../src/random.c ****     // mode and direction. This register can not be accessed during encryption/decryption. (p. 321)
  65:../src/random.c **** 
  66:../src/random.c **** 	for (uint8_t i = 0; i < 16; i++)
  67:../src/random.c **** 		AES.STATE = r_round;
  81               		.loc 1 67 0
  82 0078 91E0      		ldi r25,lo8(1)
  83               	.LVL1:
  84               	.L2:
  85               		.loc 1 67 0 is_stmt 0 discriminator 3
  86 007a 9093 C200 		sts 194,r25
  87               	.LVL2:
  88 007e 8150      		subi r24,lo8(-(-1))
  89               	.LVL3:
  66:../src/random.c **** 		AES.STATE = r_round;
  90               		.loc 1 66 0 is_stmt 1 discriminator 3
  91 0080 01F4      		brne .L2
  92               	.LBE11:
  68:../src/random.c **** 
  69:../src/random.c **** 	// CTRL – Control Register
  70:../src/random.c **** 	// Bit 2 – XOR: State XOR Load Enable
  71:../src/random.c ****     // Setting this bit enables a XOR data load to the state memory. When this bit is set, the data
  72:../src/random.c ****     // loaded to the state memory are bitwise XORed with the data currently in the state memory. Wr
  73:../src/random.c ****     // this bit to zero disables XOR load mode, and new data written to the state memory will
  74:../src/random.c ****     // overwrite the current data.
  75:../src/random.c **** 	//Bit 7 – START: Start/Run
  76:../src/random.c ****     // Setting this bit starts the encryption/decryption procedure, and this bit remains set while 
  77:../src/random.c ****     // encryption/decryption is ongoing. Writing this bit to zero will stop/abort any ongoing encry
  78:../src/random.c ****     // decryption process. This bit is automatically cleared if the SRIF or the ERROR flags in
  79:../src/random.c ****     // STATUS are set. (p. 320)
  80:../src/random.c **** 
  81:../src/random.c **** 	AES.CTRL = AES_START_bm | AES_XOR_bm;
  93               		.loc 1 81 0
  94 0082 84E8      		ldi r24,lo8(-124)
  95               	.LVL4:
  96 0084 8093 C000 		sts 192,r24
  82:../src/random.c **** 
  83:../src/random.c **** 	r_position = 0;
  97               		.loc 1 83 0
  98 0088 1092 0000 		sts r_position,__zero_reg__
  84:../src/random.c **** 	randNormHasSaved = 0;
  99               		.loc 1 84 0
 100 008c 1092 0000 		sts randNormHasSaved,__zero_reg__
 101 0090 0895      		ret
 102               		.cfi_endproc
 103               	.LFE28:
 105               		.section	.text.rand_byte,"ax",@progbits
 106               	.global	rand_byte
 108               	rand_byte:
 109               	.LFB29:
  85:../src/random.c **** }
  86:../src/random.c **** 
  87:../src/random.c **** uint8_t rand_byte(){
 110               		.loc 1 87 0
 111               		.cfi_startproc
 112               	/* prologue: function */
 113               	/* frame size = 0 */
 114               	/* stack size = 0 */
 115               	.L__stack_usage = 0
  88:../src/random.c **** 	uint8_t r;
  89:../src/random.c **** 	if (r_position == 0) while (!(AES.STATUS & AES_SRIF_bm));
 116               		.loc 1 89 0
 117 0000 9091 0000 		lds r25,r_position
 118 0004 9923      		tst r25
 119 0006 01F0      		breq .L7
  90:../src/random.c **** 	r = AES.STATE;
 120               		.loc 1 90 0
 121 0008 8091 C200 		lds r24,194
 122               	.LVL5:
  91:../src/random.c **** 	r_position++;
 123               		.loc 1 91 0
 124 000c 9F5F      		subi r25,lo8(-(1))
 125 000e 9093 0000 		sts r_position,r25
  92:../src/random.c **** 	if (r_position > 15){
 126               		.loc 1 92 0
 127 0012 9031      		cpi r25,lo8(16)
 128 0014 00F0      		brlo .L12
 129 0016 2091 0000 		lds r18,r_round
 130 001a 90E1      		ldi r25,lo8(16)
 131               	.L10:
 132               	.LVL6:
 133               	.LBB16:
 134               	.LBB17:
 135               	.LBB18:
  93:../src/random.c **** 		for (uint8_t i = 0; i < 16; i++) AES.STATE = r_round;
 136               		.loc 1 93 0
 137 001c 2093 C200 		sts 194,r18
 138               	.LVL7:
 139 0020 9150      		subi r25,lo8(-(-1))
 140               	.LVL8:
 141 0022 01F4      		brne .L10
 142               	.LBE18:
  94:../src/random.c **** 		AES.CTRL = AES_START_bm | AES_XOR_bm;
 143               		.loc 1 94 0
 144 0024 94E8      		ldi r25,lo8(-124)
 145               	.LVL9:
 146 0026 9093 C000 		sts 192,r25
  95:../src/random.c **** 		r_position = 0;
 147               		.loc 1 95 0
 148 002a 1092 0000 		sts r_position,__zero_reg__
 149 002e 0895      		ret
 150               	.LVL10:
 151               	.L7:
 152               	.LBE17:
 153               	.LBE16:
  89:../src/random.c **** 	r = AES.STATE;
 154               		.loc 1 89 0 discriminator 1
 155 0030 8091 C100 		lds r24,193
 156 0034 80FF      		sbrs r24,0
 157 0036 00C0      		rjmp .L7
  90:../src/random.c **** 	r_position++;
 158               		.loc 1 90 0
 159 0038 8091 C200 		lds r24,194
 160               	.LVL11:
  91:../src/random.c **** 	if (r_position > 15){
 161               		.loc 1 91 0
 162 003c 91E0      		ldi r25,lo8(1)
 163 003e 9093 0000 		sts r_position,r25
 164               	.L12:
  96:../src/random.c **** 	}
  97:../src/random.c **** 	return r;
  98:../src/random.c **** }
 165               		.loc 1 98 0
 166 0042 0895      		ret
 167               		.cfi_endproc
 168               	.LFE29:
 170               		.section	.text.rand_short,"ax",@progbits
 171               	.global	rand_short
 173               	rand_short:
 174               	.LFB30:
  99:../src/random.c **** 
 100:../src/random.c **** uint16_t rand_short(){
 175               		.loc 1 100 0
 176               		.cfi_startproc
 177 0000 CF93      		push r28
 178               	.LCFI0:
 179               		.cfi_def_cfa_offset 4
 180               		.cfi_offset 28, -3
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 1 */
 184               	.L__stack_usage = 1
 101:../src/random.c **** 	return ((uint16_t)rand_byte()<<8)|((uint16_t)rand_byte());
 185               		.loc 1 101 0
 186 0002 0E94 0000 		call rand_byte
 187               	.LVL12:
 188 0006 C82F      		mov r28,r24
 189 0008 0E94 0000 		call rand_byte
 190               	.LVL13:
 191 000c 2C2F      		mov r18,r28
 192 000e 30E0      		ldi r19,0
 193 0010 322F      		mov r19,r18
 194 0012 2227      		clr r18
 102:../src/random.c **** }
 195               		.loc 1 102 0
 196 0014 A901      		movw r20,r18
 197 0016 482B      		or r20,r24
 198 0018 CA01      		movw r24,r20
 199               	/* epilogue start */
 200 001a CF91      		pop r28
 201 001c 0895      		ret
 202               		.cfi_endproc
 203               	.LFE30:
 205               		.section	.text.rand_quad,"ax",@progbits
 206               	.global	rand_quad
 208               	rand_quad:
 209               	.LFB31:
 103:../src/random.c **** 
 104:../src/random.c **** uint32_t rand_quad(){
 210               		.loc 1 104 0
 211               		.cfi_startproc
 212 0000 0F93      		push r16
 213               	.LCFI1:
 214               		.cfi_def_cfa_offset 4
 215               		.cfi_offset 16, -3
 216 0002 1F93      		push r17
 217               	.LCFI2:
 218               		.cfi_def_cfa_offset 5
 219               		.cfi_offset 17, -4
 220 0004 CF93      		push r28
 221               	.LCFI3:
 222               		.cfi_def_cfa_offset 6
 223               		.cfi_offset 28, -5
 224 0006 DF93      		push r29
 225               	.LCFI4:
 226               		.cfi_def_cfa_offset 7
 227               		.cfi_offset 29, -6
 228               	/* prologue: function */
 229               	/* frame size = 0 */
 230               	/* stack size = 4 */
 231               	.L__stack_usage = 4
 232               	.LBB19:
 233               	.LBB20:
 101:../src/random.c **** }
 234               		.loc 1 101 0
 235 0008 0E94 0000 		call rand_byte
 236               	.LVL14:
 237 000c 182F      		mov r17,r24
 238 000e 0E94 0000 		call rand_byte
 239               	.LVL15:
 240 0012 D82F      		mov r29,r24
 241               	.LBE20:
 242               	.LBE19:
 243               	.LBB21:
 244               	.LBB22:
 245 0014 0E94 0000 		call rand_byte
 246               	.LVL16:
 247 0018 C82F      		mov r28,r24
 248 001a 0E94 0000 		call rand_byte
 249               	.LVL17:
 250               	.LBE22:
 251               	.LBE21:
 105:../src/random.c **** 	return ((uint32_t)rand_short()<<16)|((uint32_t)rand_short());
 252               		.loc 1 105 0
 253 001e 4D2F      		mov r20,r29
 254 0020 50E0      		ldi r21,0
 255 0022 512B      		or r21,r17
 256 0024 60E0      		ldi r22,0
 257 0026 70E0      		ldi r23,0
 258 0028 BA01      		movw r22,r20
 259 002a 5527      		clr r21
 260 002c 4427      		clr r20
 261 002e 2C2F      		mov r18,r28
 262 0030 30E0      		ldi r19,0
 263 0032 322F      		mov r19,r18
 264 0034 2227      		clr r18
 265 0036 8901      		movw r16,r18
 266 0038 082B      		or r16,r24
 267 003a C801      		movw r24,r16
 268 003c A0E0      		ldi r26,0
 269 003e B0E0      		ldi r27,0
 270 0040 8A01      		movw r16,r20
 271 0042 9B01      		movw r18,r22
 272 0044 082B      		or r16,r24
 273 0046 192B      		or r17,r25
 274 0048 2A2B      		or r18,r26
 275 004a 3B2B      		or r19,r27
 276 004c C901      		movw r24,r18
 277 004e B801      		movw r22,r16
 278               	/* epilogue start */
 106:../src/random.c **** }
 279               		.loc 1 106 0
 280 0050 DF91      		pop r29
 281 0052 CF91      		pop r28
 282 0054 1F91      		pop r17
 283 0056 0F91      		pop r16
 284 0058 0895      		ret
 285               		.cfi_endproc
 286               	.LFE31:
 288               	.global	__floatunsisf
 289               	.global	__mulsf3
 290               		.section	.text.rand_real,"ax",@progbits
 291               	.global	rand_real
 293               	rand_real:
 294               	.LFB32:
 107:../src/random.c **** 
 108:../src/random.c **** float rand_real(){
 295               		.loc 1 108 0
 296               		.cfi_startproc
 297               	/* prologue: function */
 298               	/* frame size = 0 */
 299               	/* stack size = 0 */
 300               	.L__stack_usage = 0
 109:../src/random.c **** 	return (((float)rand_quad())/4294967295.0);
 301               		.loc 1 109 0
 302 0000 0E94 0000 		call rand_quad
 303               	.LVL18:
 304 0004 0E94 0000 		call __floatunsisf
 305               	.LVL19:
 306 0008 20E0      		ldi r18,0
 307 000a 30E0      		ldi r19,0
 308 000c 40E8      		ldi r20,lo8(-128)
 309 000e 5FE2      		ldi r21,lo8(47)
 310 0010 0E94 0000 		call __mulsf3
 311               	.LVL20:
 110:../src/random.c **** }
 312               		.loc 1 110 0
 313 0014 0895      		ret
 314               		.cfi_endproc
 315               	.LFE32:
 317               	.global	__addsf3
 318               		.section	.text.rand_norm,"ax",@progbits
 319               	.global	rand_norm
 321               	rand_norm:
 322               	.LFB33:
 111:../src/random.c **** 
 112:../src/random.c **** float rand_norm(float mean, float stdDev){
 323               		.loc 1 112 0
 324               		.cfi_startproc
 325               	.LVL21:
 326 0000 4F92      		push r4
 327               	.LCFI5:
 328               		.cfi_def_cfa_offset 4
 329               		.cfi_offset 4, -3
 330 0002 5F92      		push r5
 331               	.LCFI6:
 332               		.cfi_def_cfa_offset 5
 333               		.cfi_offset 5, -4
 334 0004 6F92      		push r6
 335               	.LCFI7:
 336               		.cfi_def_cfa_offset 6
 337               		.cfi_offset 6, -5
 338 0006 7F92      		push r7
 339               	.LCFI8:
 340               		.cfi_def_cfa_offset 7
 341               		.cfi_offset 7, -6
 342 0008 8F92      		push r8
 343               	.LCFI9:
 344               		.cfi_def_cfa_offset 8
 345               		.cfi_offset 8, -7
 346 000a 9F92      		push r9
 347               	.LCFI10:
 348               		.cfi_def_cfa_offset 9
 349               		.cfi_offset 9, -8
 350 000c AF92      		push r10
 351               	.LCFI11:
 352               		.cfi_def_cfa_offset 10
 353               		.cfi_offset 10, -9
 354 000e BF92      		push r11
 355               	.LCFI12:
 356               		.cfi_def_cfa_offset 11
 357               		.cfi_offset 11, -10
 358 0010 CF92      		push r12
 359               	.LCFI13:
 360               		.cfi_def_cfa_offset 12
 361               		.cfi_offset 12, -11
 362 0012 DF92      		push r13
 363               	.LCFI14:
 364               		.cfi_def_cfa_offset 13
 365               		.cfi_offset 13, -12
 366 0014 EF92      		push r14
 367               	.LCFI15:
 368               		.cfi_def_cfa_offset 14
 369               		.cfi_offset 14, -13
 370 0016 FF92      		push r15
 371               	.LCFI16:
 372               		.cfi_def_cfa_offset 15
 373               		.cfi_offset 15, -14
 374 0018 CF93      		push r28
 375               	.LCFI17:
 376               		.cfi_def_cfa_offset 16
 377               		.cfi_offset 28, -15
 378 001a DF93      		push r29
 379               	.LCFI18:
 380               		.cfi_def_cfa_offset 17
 381               		.cfi_offset 29, -16
 382 001c CDB7      		in r28,__SP_L__
 383 001e DEB7      		in r29,__SP_H__
 384               	.LCFI19:
 385               		.cfi_def_cfa_register 28
 386 0020 2897      		sbiw r28,8
 387               	.LCFI20:
 388               		.cfi_def_cfa_offset 25
 389 0022 CDBF      		out __SP_L__,r28
 390 0024 DEBF      		out __SP_H__,r29
 391               	/* prologue: function */
 392               	/* frame size = 8 */
 393               	/* stack size = 22 */
 394               	.L__stack_usage = 22
 395 0026 6B01      		movw r12,r22
 396 0028 7C01      		movw r14,r24
 397 002a 4901      		movw r8,r18
 398 002c 5A01      		movw r10,r20
 113:../src/random.c **** 	float uA, uB, r, th;
 114:../src/random.c **** 	if(randNormHasSaved){
 399               		.loc 1 114 0
 400 002e 8091 0000 		lds r24,randNormHasSaved
 401 0032 8823      		tst r24
 402 0034 01F0      		breq .L21
 115:../src/random.c **** 		randNormHasSaved = 0;
 403               		.loc 1 115 0
 404 0036 1092 0000 		sts randNormHasSaved,__zero_reg__
 116:../src/random.c **** 		return stdDev*randNormSavedValue + mean;
 405               		.loc 1 116 0
 406 003a 2091 0000 		lds r18,randNormSavedValue
 407 003e 3091 0000 		lds r19,randNormSavedValue+1
 408 0042 4091 0000 		lds r20,randNormSavedValue+2
 409 0046 5091 0000 		lds r21,randNormSavedValue+3
 410               	.LVL22:
 411 004a C501      		movw r24,r10
 412 004c B401      		movw r22,r8
 413               	.LVL23:
 414 004e 0E94 0000 		call __mulsf3
 415               	.LVL24:
 416 0052 A701      		movw r20,r14
 417 0054 9601      		movw r18,r12
 418 0056 0E94 0000 		call __addsf3
 419               	.LVL25:
 420               	.L22:
 421               	/* epilogue start */
 117:../src/random.c **** 	}else{
 118:../src/random.c **** 		uA = rand_real();
 119:../src/random.c **** 		uB = rand_real();
 120:../src/random.c **** 		r = sqrtf(-2*log(uA));
 121:../src/random.c **** 		th = 2.0*M_PI*uB;
 122:../src/random.c **** 		randNormSavedValue = r*sinf(th);
 123:../src/random.c **** 		randNormHasSaved = 1;
 124:../src/random.c **** 		return stdDev*r*cosf(th) + mean;
 125:../src/random.c **** 	}
 126:../src/random.c **** }
 422               		.loc 1 126 0
 423 005a 2896      		adiw r28,8
 424 005c CDBF      		out __SP_L__,r28
 425 005e DEBF      		out __SP_H__,r29
 426 0060 DF91      		pop r29
 427 0062 CF91      		pop r28
 428 0064 FF90      		pop r15
 429 0066 EF90      		pop r14
 430 0068 DF90      		pop r13
 431 006a CF90      		pop r12
 432               	.LVL26:
 433 006c BF90      		pop r11
 434 006e AF90      		pop r10
 435 0070 9F90      		pop r9
 436 0072 8F90      		pop r8
 437               	.LVL27:
 438 0074 7F90      		pop r7
 439 0076 6F90      		pop r6
 440 0078 5F90      		pop r5
 441 007a 4F90      		pop r4
 442 007c 0895      		ret
 443               	.LVL28:
 444               	.L21:
 445               	.LBB23:
 446               	.LBB24:
 109:../src/random.c **** }
 447               		.loc 1 109 0
 448 007e 0E94 0000 		call rand_quad
 449               	.LVL29:
 450 0082 2B01      		movw r4,r22
 451 0084 3C01      		movw r6,r24
 452               	.LBE24:
 453               	.LBE23:
 454               	.LBB25:
 455               	.LBB26:
 456 0086 0E94 0000 		call rand_quad
 457               	.LVL30:
 458 008a 6D83      		std Y+5,r22
 459 008c 7E83      		std Y+6,r23
 460 008e 8F83      		std Y+7,r24
 461 0090 9887      		std Y+8,r25
 462               	.LBE26:
 463               	.LBE25:
 120:../src/random.c **** 		th = 2.0*M_PI*uB;
 464               		.loc 1 120 0
 465 0092 C301      		movw r24,r6
 466 0094 B201      		movw r22,r4
 467 0096 0E94 0000 		call __floatunsisf
 468               	.LVL31:
 469 009a 20E0      		ldi r18,0
 470 009c 30E0      		ldi r19,0
 471 009e 40E8      		ldi r20,lo8(-128)
 472 00a0 5FE2      		ldi r21,lo8(47)
 473 00a2 0E94 0000 		call __mulsf3
 474               	.LVL32:
 475 00a6 0E94 0000 		call log
 476               	.LVL33:
 477 00aa 20E0      		ldi r18,0
 478 00ac 30E0      		ldi r19,0
 479 00ae 40E0      		ldi r20,0
 480 00b0 50EC      		ldi r21,lo8(-64)
 481 00b2 0E94 0000 		call __mulsf3
 482               	.LVL34:
 483 00b6 0E94 0000 		call sqrtf
 484               	.LVL35:
 485 00ba 6983      		std Y+1,r22
 486 00bc 7A83      		std Y+2,r23
 487 00be 8B83      		std Y+3,r24
 488 00c0 9C83      		std Y+4,r25
 489               	.LVL36:
 121:../src/random.c **** 		randNormSavedValue = r*sinf(th);
 490               		.loc 1 121 0
 491 00c2 6D81      		ldd r22,Y+5
 492 00c4 7E81      		ldd r23,Y+6
 493 00c6 8F81      		ldd r24,Y+7
 494 00c8 9885      		ldd r25,Y+8
 495               	.LVL37:
 496 00ca 0E94 0000 		call __floatunsisf
 497               	.LVL38:
 498 00ce 20E0      		ldi r18,0
 499 00d0 30E0      		ldi r19,0
 500 00d2 40E8      		ldi r20,lo8(-128)
 501 00d4 5FE2      		ldi r21,lo8(47)
 502 00d6 0E94 0000 		call __mulsf3
 503               	.LVL39:
 504 00da 2BED      		ldi r18,lo8(-37)
 505 00dc 3FE0      		ldi r19,lo8(15)
 506 00de 49EC      		ldi r20,lo8(-55)
 507 00e0 50E4      		ldi r21,lo8(64)
 508 00e2 0E94 0000 		call __mulsf3
 509               	.LVL40:
 510 00e6 2B01      		movw r4,r22
 511 00e8 3C01      		movw r6,r24
 512               	.LVL41:
 122:../src/random.c **** 		randNormHasSaved = 1;
 513               		.loc 1 122 0
 514 00ea 0E94 0000 		call sin
 515               	.LVL42:
 516 00ee 9B01      		movw r18,r22
 517 00f0 AC01      		movw r20,r24
 518 00f2 6981      		ldd r22,Y+1
 519 00f4 7A81      		ldd r23,Y+2
 520 00f6 8B81      		ldd r24,Y+3
 521 00f8 9C81      		ldd r25,Y+4
 522 00fa 0E94 0000 		call __mulsf3
 523               	.LVL43:
 524 00fe 6093 0000 		sts randNormSavedValue,r22
 525 0102 7093 0000 		sts randNormSavedValue+1,r23
 526 0106 8093 0000 		sts randNormSavedValue+2,r24
 527 010a 9093 0000 		sts randNormSavedValue+3,r25
 123:../src/random.c **** 		return stdDev*r*cosf(th) + mean;
 528               		.loc 1 123 0
 529 010e 81E0      		ldi r24,lo8(1)
 530 0110 8093 0000 		sts randNormHasSaved,r24
 124:../src/random.c **** 	}
 531               		.loc 1 124 0
 532 0114 C301      		movw r24,r6
 533 0116 B201      		movw r22,r4
 534 0118 0E94 0000 		call cos
 535               	.LVL44:
 536 011c 2B01      		movw r4,r22
 537 011e 3C01      		movw r6,r24
 538               	.LVL45:
 539 0120 2981      		ldd r18,Y+1
 540 0122 3A81      		ldd r19,Y+2
 541 0124 4B81      		ldd r20,Y+3
 542 0126 5C81      		ldd r21,Y+4
 543 0128 C501      		movw r24,r10
 544 012a B401      		movw r22,r8
 545 012c 0E94 0000 		call __mulsf3
 546               	.LVL46:
 547 0130 A301      		movw r20,r6
 548 0132 9201      		movw r18,r4
 549 0134 0E94 0000 		call __mulsf3
 550               	.LVL47:
 551 0138 A701      		movw r20,r14
 552 013a 9601      		movw r18,r12
 553 013c 0E94 0000 		call __addsf3
 554               	.LVL48:
 555 0140 00C0      		rjmp .L22
 556               		.cfi_endproc
 557               	.LFE33:
 559               		.section	.bss.randNormSavedValue,"aw",@nobits
 562               	randNormSavedValue:
 563 0000 0000 0000 		.zero	4
 564               		.section	.bss.randNormHasSaved,"aw",@nobits
 567               	randNormHasSaved:
 568 0000 00        		.zero	1
 569               		.section	.bss.r_position,"aw",@nobits
 572               	r_position:
 573 0000 00        		.zero	1
 574               		.section	.bss.r_round,"aw",@nobits
 577               	r_round:
 578 0000 00        		.zero	1
 579               		.comm	rtc_epoch,2,1
 580               		.comm	droplet_ID,2,1
 581               		.text
 582               	.Letext0:
 583               		.file 2 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 584               		.file 3 "C:/Program Files (x86)/Atmel/Studio/7.0/Packs/atmel/XMEGAA_DFP/1.1.68/include/avr/iox128a
 585               		.file 4 "../include/droplet_base.h"
 586               		.file 5 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
DEFINED SYMBOLS
                            *ABS*:00000000 random.c
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:2      *ABS*:0000003e __SP_H__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:3      *ABS*:0000003d __SP_L__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:4      *ABS*:0000003f __SREG__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:6      *ABS*:00000034 __CCP__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:7      *ABS*:00000000 __tmp_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:8      *ABS*:00000001 __zero_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:15     .text.random_init:00000000 random_init
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:577    .bss.r_round:00000000 r_round
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:572    .bss.r_position:00000000 r_position
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:567    .bss.randNormHasSaved:00000000 randNormHasSaved
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:108    .text.rand_byte:00000000 rand_byte
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:173    .text.rand_short:00000000 rand_short
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:208    .text.rand_quad:00000000 rand_quad
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:293    .text.rand_real:00000000 rand_real
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:321    .text.rand_norm:00000000 rand_norm
C:\Users\JOHNK~1\AppData\Local\Temp\ccRuW57c.s:562    .bss.randNormSavedValue:00000000 randNormSavedValue
                            *COM*:00000002 rtc_epoch
                            *COM*:00000002 droplet_ID

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__addsf3
log
sqrtf
sin
cos
__do_clear_bss
