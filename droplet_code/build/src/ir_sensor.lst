   1               		.file	"ir_sensor.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__CCP__ = 0x34
   7               	__tmp_reg__ = 0
   8               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  11               		.cfi_sections	.debug_frame
  12               		.section	.text.ir_sensor_init,"ax",@progbits
  13               	.global	ir_sensor_init
  15               	ir_sensor_init:
  16               	.LFB62:
  17               		.file 1 "../src/ir_sensor.c"
   1:../src/ir_sensor.c **** #include "ir_sensor.h"
   2:../src/ir_sensor.c **** 
   3:../src/ir_sensor.c **** #ifdef AUDIO_DROPLET
   4:../src/ir_sensor.c **** 	ADC_CH_t* ir_sense_channels[6]  = {&(ADCA.CH0), &(ADCA.CH1), &(ADCA.CH2), &(ADCB.CH0), &(ADCB.CH1)
   5:../src/ir_sensor.c **** #else
   6:../src/ir_sensor.c **** 	const uint8_t mux_sensor_selectors[6] = {MUX_IR_SENSOR_0, MUX_IR_SENSOR_1, MUX_IR_SENSOR_2, MUX_IR
   7:../src/ir_sensor.c **** #endif
   8:../src/ir_sensor.c **** 
   9:../src/ir_sensor.c **** static int16_t  ir_sense_baseline[6];
  10:../src/ir_sensor.c **** 
  11:../src/ir_sensor.c **** // IR sensors use ADCB channel 0, all the time
  12:../src/ir_sensor.c **** void ir_sensor_init(){
  18               		.loc 1 12 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
  13:../src/ir_sensor.c **** 	#ifdef AUDIO_DROPLET
  14:../src/ir_sensor.c **** 		/* SET INPUT PINS AS INPUTS */
  15:../src/ir_sensor.c **** 		PORTA.DIRCLR = PIN5_bm | PIN6_bm | PIN7_bm;
  16:../src/ir_sensor.c **** 		PORTB.DIRCLR = PIN4_bm | PIN2_bm | PIN3_bm;
  17:../src/ir_sensor.c **** 	
  18:../src/ir_sensor.c **** 		//
  19:../src/ir_sensor.c **** 		//IR SENSORS ACTING WEIRD? TRY COMMENTING OUT THE BELOW.
  20:../src/ir_sensor.c **** 		//BELOW RECOMMENDED BY note on pg 153 of the manual
  21:../src/ir_sensor.c **** 		//
  22:../src/ir_sensor.c **** 		PORTA.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
  23:../src/ir_sensor.c **** 		PORTA.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
  24:../src/ir_sensor.c **** 		PORTA.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;
  25:../src/ir_sensor.c **** 		PORTB.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
  26:../src/ir_sensor.c **** 		PORTB.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
  27:../src/ir_sensor.c **** 		PORTB.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
  28:../src/ir_sensor.c **** 	
  29:../src/ir_sensor.c **** 		ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
  30:../src/ir_sensor.c **** 		ADCA.CTRLB = ADC_RESOLUTION_12BIT_gc | ADC_CONMODE_bm/* | ADC_FREERUN_bm*/;
  31:../src/ir_sensor.c **** 		ADCA.PRESCALER = ADC_PRESCALER_DIV512_gc;
  32:../src/ir_sensor.c **** 		ADCA.CALL = PRODSIGNATURES_ADCACAL0;
  33:../src/ir_sensor.c **** 		ADCA.CALH = PRODSIGNATURES_ADCACAL1;
  34:../src/ir_sensor.c **** 	
  35:../src/ir_sensor.c **** 		ADCB.REFCTRL = ADC_REFSEL_AREFA_gc;
  36:../src/ir_sensor.c **** 		ADCB.CTRLB = ADC_RESOLUTION_12BIT_gc | ADC_CONMODE_bm/* | ADC_FREERUN_bm*/; //12bit resolution, a
  37:../src/ir_sensor.c **** 		ADCB.PRESCALER = ADC_PRESCALER_DIV512_gc;
  38:../src/ir_sensor.c **** 		ADCB.CALL = PRODSIGNATURES_ADCBCAL0;
  39:../src/ir_sensor.c **** 		ADCB.CALH = PRODSIGNATURES_ADCBCAL1;
  40:../src/ir_sensor.c **** 	
  41:../src/ir_sensor.c **** 		ADCA.CH0.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  42:../src/ir_sensor.c **** 		ADCA.CH0.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN5_gc;	// use VREF_IN for the 
  43:../src/ir_sensor.c **** 		ADCA.CH1.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  44:../src/ir_sensor.c **** 		ADCA.CH1.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN6_gc;	// use VREF_IN for the 
  45:../src/ir_sensor.c **** 		ADCA.CH2.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  46:../src/ir_sensor.c **** 		ADCA.CH2.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN7_gc;	// use VREF_IN for the 
  47:../src/ir_sensor.c **** 
  48:../src/ir_sensor.c **** 		ADCB.CH0.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  49:../src/ir_sensor.c **** 		ADCB.CH0.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN4_gc;	// use VREF_IN for the 
  50:../src/ir_sensor.c **** 		ADCB.CH1.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  51:../src/ir_sensor.c **** 		ADCB.CH1.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN2_gc;	// use VREF_IN for the 
  52:../src/ir_sensor.c **** 		ADCB.CH2.CTRL =ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires s
  53:../src/ir_sensor.c **** 		ADCB.CH2.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc | ADC_CH_MUXPOS_PIN3_gc;	// use VREF_IN for the 
  54:../src/ir_sensor.c **** 
  55:../src/ir_sensor.c **** 
  56:../src/ir_sensor.c **** 		ADCA.CTRLA = ADC_ENABLE_bm;
  57:../src/ir_sensor.c **** 		ADCB.CTRLA = ADC_ENABLE_bm;
  58:../src/ir_sensor.c **** 		
  59:../src/ir_sensor.c **** 		//ADCA.EVCTRL = ADC_EVSEL_1234_gc | ADC_EVACT_CH012_gc | ADC_SWEEP_012_gc;
  60:../src/ir_sensor.c **** 		//ADCB.EVCTRL = ADC_EVSEL_567_gc | ADC_EVACT_CH012_gc | ADC_SWEEP_012_gc;
  61:../src/ir_sensor.c **** 	#else
  62:../src/ir_sensor.c **** 		/* SET INPUT PINS AS INPUTS */
  63:../src/ir_sensor.c **** 		IR_SENSOR_PORT.DIRCLR = ALL_IR_SENSOR_PINS_bm;
  24               		.loc 1 63 0
  25 0000 E0E2      		ldi r30,lo8(32)
  26 0002 F6E0      		ldi r31,lo8(6)
  27 0004 8CEF      		ldi r24,lo8(-4)
  28 0006 8283      		std Z+2,r24
  64:../src/ir_sensor.c **** 		
  65:../src/ir_sensor.c **** 		PORTB.PIN5CTRL = PORT_ISC_INPUT_DISABLE_gc;
  29               		.loc 1 65 0
  30 0008 87E0      		ldi r24,lo8(7)
  31 000a 858B      		std Z+21,r24
  66:../src/ir_sensor.c **** 		PORTB.PIN6CTRL = PORT_ISC_INPUT_DISABLE_gc;
  32               		.loc 1 66 0
  33 000c 868B      		std Z+22,r24
  67:../src/ir_sensor.c **** 		PORTB.PIN7CTRL = PORT_ISC_INPUT_DISABLE_gc;
  34               		.loc 1 67 0
  35 000e 878B      		std Z+23,r24
  68:../src/ir_sensor.c **** 		PORTB.PIN4CTRL = PORT_ISC_INPUT_DISABLE_gc;
  36               		.loc 1 68 0
  37 0010 848B      		std Z+20,r24
  69:../src/ir_sensor.c **** 		PORTB.PIN2CTRL = PORT_ISC_INPUT_DISABLE_gc;
  38               		.loc 1 69 0
  39 0012 828B      		std Z+18,r24
  70:../src/ir_sensor.c **** 		PORTB.PIN3CTRL = PORT_ISC_INPUT_DISABLE_gc;
  40               		.loc 1 70 0
  41 0014 838B      		std Z+19,r24
  71:../src/ir_sensor.c **** 
  72:../src/ir_sensor.c **** 		ADCB.REFCTRL = ADC_REFSEL_AREFA_gc;
  42               		.loc 1 72 0
  43 0016 E0E4      		ldi r30,lo8(64)
  44 0018 F2E0      		ldi r31,lo8(2)
  45 001a 90E2      		ldi r25,lo8(32)
  46 001c 9283      		std Z+2,r25
  73:../src/ir_sensor.c **** 		ADCB.CTRLB = ADC_RESOLUTION_12BIT_gc | ADC_CONMODE_bm; //12bit resolution, and sets it to signed 
  47               		.loc 1 73 0
  48 001e 90E1      		ldi r25,lo8(16)
  49 0020 9183      		std Z+1,r25
  74:../src/ir_sensor.c **** 		ADCB.PRESCALER = ADC_PRESCALER_DIV512_gc;
  50               		.loc 1 74 0
  51 0022 8483      		std Z+4,r24
  75:../src/ir_sensor.c **** 		ADCB.CH0.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN2_bm;	// differential input. requires 
  52               		.loc 1 75 0
  53 0024 83E1      		ldi r24,lo8(19)
  54 0026 80A3      		std Z+32,r24
  76:../src/ir_sensor.c **** 		ADCB.CH0.MUXCTRL = ADC_CH_MUXNEG_INTGND_MODE4_gc;	// use VREF_IN for the negative input (0.54 V)
  55               		.loc 1 76 0
  56 0028 84E0      		ldi r24,lo8(4)
  57 002a 81A3      		std Z+33,r24
  77:../src/ir_sensor.c **** 		ADCB.CALL = PRODSIGNATURES_ADCBCAL0;
  58               		.loc 1 77 0
  59 002c 84B5      		in r24,0x24
  60 002e 8487      		std Z+12,r24
  78:../src/ir_sensor.c **** 		ADCB.CALH = PRODSIGNATURES_ADCBCAL1;
  61               		.loc 1 78 0
  62 0030 85B5      		in r24,0x25
  63 0032 8587      		std Z+13,r24
  79:../src/ir_sensor.c **** 		ADCB.CTRLA = ADC_ENABLE_bm;
  64               		.loc 1 79 0
  65 0034 81E0      		ldi r24,lo8(1)
  66 0036 8083      		st Z,r24
  67               	.LVL0:
  68               	.LBB262:
  80:../src/ir_sensor.c **** 	#endif
  81:../src/ir_sensor.c **** 	
  82:../src/ir_sensor.c **** 	for(uint8_t dir=0;dir<6;dir++){
  83:../src/ir_sensor.c **** 		ir_sense_baseline[dir]=0;
  69               		.loc 1 83 0
  70 0038 E0E0      		ldi r30,lo8(ir_sense_baseline)
  71 003a F0E0      		ldi r31,hi8(ir_sense_baseline)
  72 003c 1082      		st Z,__zero_reg__
  73 003e 1182      		std Z+1,__zero_reg__
  74               	.LVL1:
  75 0040 1282      		std Z+2,__zero_reg__
  76 0042 1382      		std Z+3,__zero_reg__
  77               	.LVL2:
  78 0044 1482      		std Z+4,__zero_reg__
  79 0046 1582      		std Z+5,__zero_reg__
  80               	.LVL3:
  81 0048 1682      		std Z+6,__zero_reg__
  82 004a 1782      		std Z+7,__zero_reg__
  83               	.LVL4:
  84 004c 1086      		std Z+8,__zero_reg__
  85 004e 1186      		std Z+9,__zero_reg__
  86               	.LVL5:
  87 0050 1286      		std Z+10,__zero_reg__
  88 0052 1386      		std Z+11,__zero_reg__
  89               	.LVL6:
  90               	.LBE262:
  84:../src/ir_sensor.c **** 	}
  85:../src/ir_sensor.c **** 	schedule_task(1000,initialize_ir_baselines,NULL);
  91               		.loc 1 85 0
  92 0054 20E0      		ldi r18,0
  93 0056 30E0      		ldi r19,0
  94 0058 40E0      		ldi r20,lo8(gs(initialize_ir_baselines))
  95 005a 50E0      		ldi r21,hi8(gs(initialize_ir_baselines))
  96 005c 68EE      		ldi r22,lo8(-24)
  97 005e 73E0      		ldi r23,lo8(3)
  98 0060 80E0      		ldi r24,0
  99 0062 90E0      		ldi r25,0
 100 0064 0E94 0000 		call schedule_task
 101               	.LVL7:
  86:../src/ir_sensor.c **** 	schedule_periodic_task(5407, update_ir_baselines, NULL);
 102               		.loc 1 86 0
 103 0068 20E0      		ldi r18,0
 104 006a 30E0      		ldi r19,0
 105 006c 40E0      		ldi r20,lo8(gs(update_ir_baselines))
 106 006e 50E0      		ldi r21,hi8(gs(update_ir_baselines))
 107 0070 6FE1      		ldi r22,lo8(31)
 108 0072 75E1      		ldi r23,lo8(21)
 109 0074 80E0      		ldi r24,0
 110 0076 90E0      		ldi r25,0
 111 0078 0E94 0000 		call schedule_periodic_task
 112               	.LVL8:
 113 007c 0895      		ret
 114               		.cfi_endproc
 115               	.LFE62:
 117               		.section	.text.get_ir_sensors,"ax",@progbits
 118               	.global	get_ir_sensors
 120               	get_ir_sensors:
 121               	.LFB65:
  87:../src/ir_sensor.c **** }
  88:../src/ir_sensor.c **** 
  89:../src/ir_sensor.c **** void initialize_ir_baselines(){
  90:../src/ir_sensor.c **** 	get_ir_sensors(ir_sense_baseline, 13);
  91:../src/ir_sensor.c **** 	//printf("Baselines:");
  92:../src/ir_sensor.c **** 	//for(uint8_t dir=0;dir<6;dir++){
  93:../src/ir_sensor.c **** 		//printf(" %4d", ir_sense_baseline[dir]);
  94:../src/ir_sensor.c **** 	//}
  95:../src/ir_sensor.c **** 	//printf("\r\n");	
  96:../src/ir_sensor.c **** }
  97:../src/ir_sensor.c **** 
  98:../src/ir_sensor.c **** void update_ir_baselines(){
  99:../src/ir_sensor.c **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 100:../src/ir_sensor.c **** 		if(hp_ir_block_bm){
 101:../src/ir_sensor.c **** 			return;
 102:../src/ir_sensor.c **** 		}
 103:../src/ir_sensor.c **** 		hp_ir_block_bm=0xFF;
 104:../src/ir_sensor.c **** 	}
 105:../src/ir_sensor.c **** 	int16_t prevBaselines[6];
 106:../src/ir_sensor.c **** 	for(uint8_t dir=0; dir<6; dir++){
 107:../src/ir_sensor.c **** 		prevBaselines[dir] = ir_sense_baseline[dir]; //zeroing the baseline array.
 108:../src/ir_sensor.c **** 		ir_sense_baseline[dir] = 0;
 109:../src/ir_sensor.c **** 	}
 110:../src/ir_sensor.c **** 	get_ir_sensors(ir_sense_baseline, 13);
 111:../src/ir_sensor.c **** 	for(uint8_t dir=0;dir<6;dir++){
 112:../src/ir_sensor.c **** 		ir_sense_baseline[dir] = (ir_sense_baseline[dir]+prevBaselines[dir])/2;
 113:../src/ir_sensor.c **** 	}
 114:../src/ir_sensor.c **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 115:../src/ir_sensor.c **** 		hp_ir_block_bm = 0;
 116:../src/ir_sensor.c **** 	}
 117:../src/ir_sensor.c **** }
 118:../src/ir_sensor.c **** 
 119:../src/ir_sensor.c **** void get_ir_sensors(int16_t* output_arr, uint8_t meas_per_ch){			
 122               		.loc 1 119 0
 123               		.cfi_startproc
 124               	.LVL9:
 125 0000 2F92      		push r2
 126               	.LCFI0:
 127               		.cfi_def_cfa_offset 4
 128               		.cfi_offset 2, -3
 129 0002 3F92      		push r3
 130               	.LCFI1:
 131               		.cfi_def_cfa_offset 5
 132               		.cfi_offset 3, -4
 133 0004 4F92      		push r4
 134               	.LCFI2:
 135               		.cfi_def_cfa_offset 6
 136               		.cfi_offset 4, -5
 137 0006 5F92      		push r5
 138               	.LCFI3:
 139               		.cfi_def_cfa_offset 7
 140               		.cfi_offset 5, -6
 141 0008 6F92      		push r6
 142               	.LCFI4:
 143               		.cfi_def_cfa_offset 8
 144               		.cfi_offset 6, -7
 145 000a 7F92      		push r7
 146               	.LCFI5:
 147               		.cfi_def_cfa_offset 9
 148               		.cfi_offset 7, -8
 149 000c 8F92      		push r8
 150               	.LCFI6:
 151               		.cfi_def_cfa_offset 10
 152               		.cfi_offset 8, -9
 153 000e 9F92      		push r9
 154               	.LCFI7:
 155               		.cfi_def_cfa_offset 11
 156               		.cfi_offset 9, -10
 157 0010 AF92      		push r10
 158               	.LCFI8:
 159               		.cfi_def_cfa_offset 12
 160               		.cfi_offset 10, -11
 161 0012 BF92      		push r11
 162               	.LCFI9:
 163               		.cfi_def_cfa_offset 13
 164               		.cfi_offset 11, -12
 165 0014 CF92      		push r12
 166               	.LCFI10:
 167               		.cfi_def_cfa_offset 14
 168               		.cfi_offset 12, -13
 169 0016 DF92      		push r13
 170               	.LCFI11:
 171               		.cfi_def_cfa_offset 15
 172               		.cfi_offset 13, -14
 173 0018 EF92      		push r14
 174               	.LCFI12:
 175               		.cfi_def_cfa_offset 16
 176               		.cfi_offset 14, -15
 177 001a FF92      		push r15
 178               	.LCFI13:
 179               		.cfi_def_cfa_offset 17
 180               		.cfi_offset 15, -16
 181 001c 0F93      		push r16
 182               	.LCFI14:
 183               		.cfi_def_cfa_offset 18
 184               		.cfi_offset 16, -17
 185 001e 1F93      		push r17
 186               	.LCFI15:
 187               		.cfi_def_cfa_offset 19
 188               		.cfi_offset 17, -18
 189 0020 CF93      		push r28
 190               	.LCFI16:
 191               		.cfi_def_cfa_offset 20
 192               		.cfi_offset 28, -19
 193 0022 DF93      		push r29
 194               	.LCFI17:
 195               		.cfi_def_cfa_offset 21
 196               		.cfi_offset 29, -20
 197 0024 CDB7      		in r28,__SP_L__
 198 0026 DEB7      		in r29,__SP_H__
 199               	.LCFI18:
 200               		.cfi_def_cfa_register 28
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 18 */
 204               	.L__stack_usage = 18
 205 0028 362E      		mov r3,r22
 120:../src/ir_sensor.c **** 	int16_t meas[6][meas_per_ch];	
 121:../src/ir_sensor.c **** 	#ifdef AUDIO_DROPLET
 122:../src/ir_sensor.c **** 		for(uint8_t meas_count=0;meas_count<meas_per_ch;meas_count++){
 123:../src/ir_sensor.c **** 			for(uint8_t dir=0;dir<6;dir++){	
 124:../src/ir_sensor.c **** 				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 125:../src/ir_sensor.c **** 					ir_sense_channels[dir]->CTRL |= ADC_CH_START_bm;
 126:../src/ir_sensor.c **** 					while(ir_sense_channels[dir]->INTFLAGS==0);
 127:../src/ir_sensor.c **** 					meas[dir][meas_count] = (ir_sense_channels[dir]->RES);
 128:../src/ir_sensor.c **** 					ir_sense_channels[dir]->INTFLAGS=1;
 129:../src/ir_sensor.c **** 				}
 130:../src/ir_sensor.c **** 			}
 131:../src/ir_sensor.c **** 		}
 132:../src/ir_sensor.c **** 	#else
 133:../src/ir_sensor.c **** 		for(uint8_t dir=0;dir<6;dir++){
 134:../src/ir_sensor.c **** 			ADCB.CH0.MUXCTRL &= MUX_SENSOR_CLR; //clear previous sensor selection
 135:../src/ir_sensor.c **** 			ADCB.CH0.MUXCTRL |= mux_sensor_selectors[dir];			
 136:../src/ir_sensor.c **** 			for(uint8_t meas_count=0; meas_count<meas_per_ch; meas_count++){
 137:../src/ir_sensor.c **** 				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){		
 138:../src/ir_sensor.c **** 					ADCB.CH0.CTRL |= ADC_CH_START_bm;
 139:../src/ir_sensor.c **** 					while (ADCB.CH0.INTFLAGS==0){};		// wait for measurement to complete
 140:../src/ir_sensor.c **** 					meas[dir][meas_count] = ADCB.CH0RES;
 141:../src/ir_sensor.c **** 					ADCB.CH0.INTFLAGS=1; // clear the complete flag					
 142:../src/ir_sensor.c **** 				}
 143:../src/ir_sensor.c **** 			}			
 144:../src/ir_sensor.c **** 		}
 145:../src/ir_sensor.c **** 	#endif	
 146:../src/ir_sensor.c **** 	
 147:../src/ir_sensor.c **** 	
 148:../src/ir_sensor.c **** 	for(uint8_t dir=0;dir<6;dir++){
 149:../src/ir_sensor.c **** 		if(meas_per_ch>2){
 150:../src/ir_sensor.c **** 			int16_t median = meas_find_median(&(meas[dir][2]),meas_per_ch-2);
 151:../src/ir_sensor.c **** 			//printf("%d ",median);
 152:../src/ir_sensor.c **** 			output_arr[dir] = median-ir_sense_baseline[dir];
 153:../src/ir_sensor.c **** 		}			
 154:../src/ir_sensor.c **** 		else if(meas_per_ch==2)
 155:../src/ir_sensor.c **** 			output_arr[dir] = meas_find_median(&(meas[dir][1]),meas_per_ch-1)-ir_sense_baseline[dir];
 156:../src/ir_sensor.c **** 		else
 157:../src/ir_sensor.c **** 			output_arr[dir] = meas[dir][0];
 158:../src/ir_sensor.c **** 	}
 159:../src/ir_sensor.c **** 	//for(uint8_t i=0;i<6;i++) printf("%d ", output_arr[i]);
 160:../src/ir_sensor.c **** 	//printf("\r\n");	
 161:../src/ir_sensor.c **** }
 206               		.loc 1 161 0
 207 002a 4DB6      		in r4,__SP_L__
 208 002c 5EB6      		in r5,__SP_H__
 209               	.LVL10:
 120:../src/ir_sensor.c **** 	int16_t meas[6][meas_per_ch];	
 210               		.loc 1 120 0
 211 002e 062F      		mov r16,r22
 212 0030 10E0      		ldi r17,0
 213 0032 000F      		lsl r16
 214 0034 111F      		rol r17
 215 0036 2DB7      		in r18,__SP_L__
 216 0038 3EB7      		in r19,__SP_H__
 217 003a 4CE0      		ldi r20,lo8(12)
 218 003c 649F      		mul r22,r20
 219 003e 2019      		sub r18,r0
 220 0040 3109      		sbc r19,r1
 221 0042 1124      		clr __zero_reg__
 222 0044 2DBF      		out __SP_L__,r18
 223 0046 3EBF      		out __SP_H__,r19
 224 0048 EDB7      		in r30,__SP_L__
 225 004a FEB7      		in r31,__SP_H__
 226 004c 3196      		adiw r30,1
 227 004e 4F01      		movw r8,r30
 228               	.LVL11:
 229 0050 A0E0      		ldi r26,lo8(mux_sensor_selectors+1)
 230 0052 B0E0      		ldi r27,hi8(mux_sensor_selectors+1)
 231 0054 AF01      		movw r20,r30
 232 0056 68E2      		ldi r22,lo8(40)
 233               	.LVL12:
 234               	.LBB263:
 235               	.LBB264:
 236               	.LBB265:
 141:../src/ir_sensor.c **** 				}
 237               		.loc 1 141 0
 238 0058 EE24      		clr r14
 239 005a E394      		inc r14
 240               	.LVL13:
 241               	.L8:
 242               	.LBE265:
 243               	.LBE264:
 134:../src/ir_sensor.c **** 			ADCB.CH0.MUXCTRL |= mux_sensor_selectors[dir];			
 244               		.loc 1 134 0
 245 005c 3091 6102 		lds r19,609
 246 0060 3770      		andi r19,lo8(7)
 247 0062 3093 6102 		sts 609,r19
 135:../src/ir_sensor.c **** 			for(uint8_t meas_count=0; meas_count<meas_per_ch; meas_count++){
 248               		.loc 1 135 0
 249 0066 2091 6102 		lds r18,609
 250 006a 262B      		or r18,r22
 251 006c 2093 6102 		sts 609,r18
 252               	.LVL14:
 253               	.LBB271:
 136:../src/ir_sensor.c **** 				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){		
 254               		.loc 1 136 0
 255 0070 3320      		tst r3
 256 0072 01F0      		breq .L7
 257 0074 FA01      		movw r30,r20
 258 0076 30E0      		ldi r19,0
 259               	.LVL15:
 260               	.L3:
 261               	.LBB270:
 137:../src/ir_sensor.c **** 					ADCB.CH0.CTRL |= ADC_CH_START_bm;
 262               		.loc 1 137 0
 263 0078 FFB6      		in r15,__SREG__
 264               	.LVL16:
 265               	.LBB266:
 266               	.LBB267:
 267               		.file 2 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
   1:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    All rights reserved.
   3:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
   4:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
   7:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    * Redistributions of source code must retain the above copyright
   8:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  10:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      the documentation and/or other materials provided with the
  13:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      distribution.
  14:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  15:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      contributors may be used to endorse or promote products derived
  17:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****      from this software without specific prior written permission.
  18:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  19:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** */
  31:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  32:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** /* $Id$ */
  33:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  34:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  37:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** #include <avr/io.h>
  38:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** #include <avr/interrupt.h>
  39:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  40:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** #if !defined(__DOXYGEN__)
  41:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** /* Internal helper functions. */
  42:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** {
  44:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     sei();
  45:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     return 1;
  46:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** }
  47:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  48:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** {
  50:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     cli();
 268               		.loc 2 50 0
 269               	/* #APP */
 270               	 ;  50 "c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\
 271 007a F894      		cli
 272               	 ;  0 "" 2
 273               	.LVL17:
 274               	/* #NOAPP */
 275               	.LBE267:
 276               	.LBE266:
 138:../src/ir_sensor.c **** 					while (ADCB.CH0.INTFLAGS==0){};		// wait for measurement to complete
 277               		.loc 1 138 0
 278 007c 2091 6002 		lds r18,608
 279 0080 2068      		ori r18,lo8(-128)
 280 0082 2093 6002 		sts 608,r18
 281               	.L6:
 139:../src/ir_sensor.c **** 					meas[dir][meas_count] = ADCB.CH0RES;
 282               		.loc 1 139 0 discriminator 1
 283 0086 2091 6302 		lds r18,611
 284 008a 2223      		tst r18
 285 008c 01F0      		breq .L6
 140:../src/ir_sensor.c **** 					ADCB.CH0.INTFLAGS=1; // clear the complete flag					
 286               		.loc 1 140 0 discriminator 2
 287 008e 6091 5002 		lds r22,592
 288 0092 7091 5102 		lds r23,592+1
 289 0096 6193      		st Z+,r22
 290 0098 7193      		st Z+,r23
 141:../src/ir_sensor.c **** 				}
 291               		.loc 1 141 0 discriminator 2
 292 009a E092 6302 		sts 611,r14
 293               	.LVL18:
 294               	.LBB268:
 295               	.LBB269:
  51:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     return 1;
  52:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** }
  53:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  54:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** {
  56:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     sei();
  57:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     (void)__s;
  59:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** }
  60:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  61:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** {
  63:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     cli();
  64:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     (void)__s;
  66:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** }
  67:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** 
  68:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h **** {
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     SREG = *__s;
 296               		.loc 2 70 0 discriminator 2
 297 009e FFBE      		out __SREG__,r15
  71:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
 298               		.loc 2 71 0 discriminator 2
 299               	.LVL19:
 300               	.LBE269:
 301               	.LBE268:
 302               	.LBE270:
 136:../src/ir_sensor.c **** 				ATOMIC_BLOCK(ATOMIC_RESTORESTATE){		
 303               		.loc 1 136 0 discriminator 2
 304 00a0 3F5F      		subi r19,lo8(-(1))
 305               	.LVL20:
 306 00a2 3312      		cpse r3,r19
 307 00a4 00C0      		rjmp .L3
 308               	.LVL21:
 309               	.L7:
 310 00a6 400F      		add r20,r16
 311 00a8 511F      		adc r21,r17
 312               	.LBE271:
 133:../src/ir_sensor.c **** 			ADCB.CH0.MUXCTRL &= MUX_SENSOR_CLR; //clear previous sensor selection
 313               		.loc 1 133 0
 314 00aa F0E0      		ldi r31,hi8(mux_sensor_selectors+6)
 315 00ac A030      		cpi r26,lo8(mux_sensor_selectors+6)
 316 00ae BF07      		cpc r27,r31
 317 00b0 01F0      		breq .L22
 318 00b2 6D91      		ld r22,X+
 319               	.LVL22:
 320 00b4 00C0      		rjmp .L8
 321               	.LVL23:
 322               	.L22:
 323 00b6 5401      		movw r10,r8
 324 00b8 24E0      		ldi r18,4
 325 00ba A20E      		add r10,r18
 326 00bc B11C      		adc r11,__zero_reg__
 327 00be 20E0      		ldi r18,lo8(ir_sense_baseline)
 328 00c0 622E      		mov r6,r18
 329 00c2 20E0      		ldi r18,hi8(ir_sense_baseline)
 330 00c4 722E      		mov r7,r18
 331 00c6 7C01      		movw r14,r24
 332 00c8 C12C      		mov r12,__zero_reg__
 333 00ca D12C      		mov r13,__zero_reg__
 334               	.LBE263:
 335               	.LBB272:
 336               	.LBB273:
 150:../src/ir_sensor.c **** 			//printf("%d ",median);
 337               		.loc 1 150 0
 338 00cc 3EEF      		ldi r19,lo8(-2)
 339 00ce 232E      		mov r2,r19
 340 00d0 230C      		add r2,r3
 341 00d2 00C0      		rjmp .L12
 342               	.LVL24:
 343               	.L9:
 344               	.LBE273:
 154:../src/ir_sensor.c **** 			output_arr[dir] = meas_find_median(&(meas[dir][1]),meas_per_ch-1)-ir_sense_baseline[dir];
 345               		.loc 1 154 0
 346 00d4 F2E0      		ldi r31,lo8(2)
 347 00d6 3F16      		cp r3,r31
 348 00d8 01F4      		brne .+2
 349 00da 00C0      		rjmp .L23
 157:../src/ir_sensor.c **** 	}
 350               		.loc 1 157 0
 351 00dc 0C9D      		mul r16,r12
 352 00de F001      		movw r30,r0
 353 00e0 0D9D      		mul r16,r13
 354 00e2 F00D      		add r31,r0
 355 00e4 1C9D      		mul r17,r12
 356 00e6 F00D      		add r31,r0
 357 00e8 1124      		clr r1
 358 00ea E80D      		add r30,r8
 359 00ec F91D      		adc r31,r9
 360 00ee 8081      		ld r24,Z
 361 00f0 9181      		ldd r25,Z+1
 362 00f2 F701      		movw r30,r14
 363 00f4 8083      		st Z,r24
 364 00f6 9183      		std Z+1,r25
 365               	.LVL25:
 366               	.L10:
 367 00f8 FFEF      		ldi r31,-1
 368 00fa CF1A      		sub r12,r31
 369 00fc DF0A      		sbc r13,r31
 370               	.LVL26:
 371 00fe A00E      		add r10,r16
 372 0100 B11E      		adc r11,r17
 373 0102 22E0      		ldi r18,2
 374 0104 620E      		add r6,r18
 375 0106 711C      		adc r7,__zero_reg__
 376 0108 32E0      		ldi r19,2
 377 010a E30E      		add r14,r19
 378 010c F11C      		adc r15,__zero_reg__
 148:../src/ir_sensor.c **** 		if(meas_per_ch>2){
 379               		.loc 1 148 0 discriminator 2
 380 010e 46E0      		ldi r20,6
 381 0110 C416      		cp r12,r20
 382 0112 D104      		cpc r13,__zero_reg__
 383 0114 01F0      		breq .L24
 384               	.LVL27:
 385               	.L12:
 149:../src/ir_sensor.c **** 			int16_t median = meas_find_median(&(meas[dir][2]),meas_per_ch-2);
 386               		.loc 1 149 0
 387 0116 32E0      		ldi r19,lo8(2)
 388 0118 3315      		cp r19,r3
 389 011a 00F4      		brsh .L9
 390               	.LBB274:
 150:../src/ir_sensor.c **** 			//printf("%d ",median);
 391               		.loc 1 150 0
 392 011c 622D      		mov r22,r2
 393 011e C501      		movw r24,r10
 394               	.LVL28:
 395               	.L19:
 396               	.LBE274:
 155:../src/ir_sensor.c **** 		else
 397               		.loc 1 155 0
 398 0120 0E94 0000 		call meas_find_median
 399               	.LVL29:
 400 0124 F301      		movw r30,r6
 401 0126 2081      		ld r18,Z
 402 0128 3181      		ldd r19,Z+1
 403 012a 821B      		sub r24,r18
 404 012c 930B      		sbc r25,r19
 405 012e F701      		movw r30,r14
 406 0130 8083      		st Z,r24
 407 0132 9183      		std Z+1,r25
 408 0134 00C0      		rjmp .L10
 409               	.LVL30:
 410               	.L24:
 411               	.LBE272:
 412               		.loc 1 161 0
 413 0136 4DBE      		out __SP_L__,r4
 414 0138 5EBE      		out __SP_H__,r5
 415               	/* epilogue start */
 416 013a DF91      		pop r29
 417 013c CF91      		pop r28
 418 013e 1F91      		pop r17
 419 0140 0F91      		pop r16
 420 0142 FF90      		pop r15
 421 0144 EF90      		pop r14
 422 0146 DF90      		pop r13
 423 0148 CF90      		pop r12
 424               	.LVL31:
 425 014a BF90      		pop r11
 426 014c AF90      		pop r10
 427 014e 9F90      		pop r9
 428 0150 8F90      		pop r8
 429               	.LVL32:
 430 0152 7F90      		pop r7
 431 0154 6F90      		pop r6
 432 0156 5F90      		pop r5
 433 0158 4F90      		pop r4
 434               	.LVL33:
 435 015a 3F90      		pop r3
 436               	.LVL34:
 437 015c 2F90      		pop r2
 438               	.LVL35:
 439 015e 0895      		ret
 440               	.LVL36:
 441               	.L23:
 442               	.LBB275:
 155:../src/ir_sensor.c **** 		else
 443               		.loc 1 155 0
 444 0160 61E0      		ldi r22,lo8(1)
 445 0162 C501      		movw r24,r10
 446 0164 0297      		sbiw r24,2
 447 0166 00C0      		rjmp .L19
 448               	.LBE275:
 449               		.cfi_endproc
 450               	.LFE65:
 452               		.section	.text.initialize_ir_baselines,"ax",@progbits
 453               	.global	initialize_ir_baselines
 455               	initialize_ir_baselines:
 456               	.LFB63:
  89:../src/ir_sensor.c **** 	get_ir_sensors(ir_sense_baseline, 13);
 457               		.loc 1 89 0
 458               		.cfi_startproc
 459               	/* prologue: function */
 460               	/* frame size = 0 */
 461               	/* stack size = 0 */
 462               	.L__stack_usage = 0
  90:../src/ir_sensor.c **** 	//printf("Baselines:");
 463               		.loc 1 90 0
 464 0000 6DE0      		ldi r22,lo8(13)
 465 0002 80E0      		ldi r24,lo8(ir_sense_baseline)
 466 0004 90E0      		ldi r25,hi8(ir_sense_baseline)
 467 0006 0C94 0000 		jmp get_ir_sensors
 468               	.LVL37:
 469               		.cfi_endproc
 470               	.LFE63:
 472               		.section	.text.update_ir_baselines,"ax",@progbits
 473               	.global	update_ir_baselines
 475               	update_ir_baselines:
 476               	.LFB64:
  98:../src/ir_sensor.c **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
 477               		.loc 1 98 0
 478               		.cfi_startproc
 479 0000 EF92      		push r14
 480               	.LCFI19:
 481               		.cfi_def_cfa_offset 4
 482               		.cfi_offset 14, -3
 483 0002 FF92      		push r15
 484               	.LCFI20:
 485               		.cfi_def_cfa_offset 5
 486               		.cfi_offset 15, -4
 487 0004 0F93      		push r16
 488               	.LCFI21:
 489               		.cfi_def_cfa_offset 6
 490               		.cfi_offset 16, -5
 491 0006 1F93      		push r17
 492               	.LCFI22:
 493               		.cfi_def_cfa_offset 7
 494               		.cfi_offset 17, -6
 495 0008 CF93      		push r28
 496               	.LCFI23:
 497               		.cfi_def_cfa_offset 8
 498               		.cfi_offset 28, -7
 499 000a DF93      		push r29
 500               	.LCFI24:
 501               		.cfi_def_cfa_offset 9
 502               		.cfi_offset 29, -8
 503 000c CDB7      		in r28,__SP_L__
 504 000e DEB7      		in r29,__SP_H__
 505               	.LCFI25:
 506               		.cfi_def_cfa_register 28
 507 0010 2C97      		sbiw r28,12
 508               	.LCFI26:
 509               		.cfi_def_cfa_offset 21
 510 0012 CDBF      		out __SP_L__,r28
 511 0014 DEBF      		out __SP_H__,r29
 512               	/* prologue: function */
 513               	/* frame size = 12 */
 514               	/* stack size = 18 */
 515               	.L__stack_usage = 18
 516               	.LBB301:
  99:../src/ir_sensor.c **** 		if(hp_ir_block_bm){
 517               		.loc 1 99 0
 518 0016 9FB7      		in r25,__SREG__
 519               	.LVL38:
 520               	.LBB302:
 521               	.LBB303:
  50:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     return 1;
 522               		.loc 2 50 0
 523               	/* #APP */
 524               	 ;  50 "c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\
 525 0018 F894      		cli
 526               	 ;  0 "" 2
 527               	.LVL39:
 528               	/* #NOAPP */
 529               	.LBE303:
 530               	.LBE302:
 100:../src/ir_sensor.c **** 			return;
 531               		.loc 1 100 0
 532 001a 8091 0000 		lds r24,hp_ir_block_bm
 533 001e 8111      		cpse r24,__zero_reg__
 534 0020 00C0      		rjmp .L27
 103:../src/ir_sensor.c **** 	}
 535               		.loc 1 103 0 discriminator 2
 536 0022 8FEF      		ldi r24,lo8(-1)
 537 0024 8093 0000 		sts hp_ir_block_bm,r24
 538               	.LVL40:
 539               	.LBB304:
 540               	.LBB305:
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
 541               		.loc 2 70 0 discriminator 2
 542 0028 9FBF      		out __SREG__,r25
 543               		.loc 2 71 0 discriminator 2
 544               	.LVL41:
 545 002a 8E01      		movw r16,r28
 546 002c 0F5F      		subi r16,-1
 547 002e 1F4F      		sbci r17,-1
 548 0030 30E0      		ldi r19,lo8(ir_sense_baseline)
 549 0032 E32E      		mov r14,r19
 550 0034 30E0      		ldi r19,hi8(ir_sense_baseline)
 551 0036 F32E      		mov r15,r19
 552 0038 F701      		movw r30,r14
 553 003a D801      		movw r26,r16
 554               	.LVL42:
 555               	.L28:
 556               	.LBE305:
 557               	.LBE304:
 558               	.LBE301:
 559               	.LBB308:
 107:../src/ir_sensor.c **** 		ir_sense_baseline[dir] = 0;
 560               		.loc 1 107 0 discriminator 3
 561 003c 8081      		ld r24,Z
 562 003e 9181      		ldd r25,Z+1
 563 0040 8D93      		st X+,r24
 564 0042 9D93      		st X+,r25
 108:../src/ir_sensor.c **** 	}
 565               		.loc 1 108 0 discriminator 3
 566 0044 1192      		st Z+,__zero_reg__
 567 0046 1192      		st Z+,__zero_reg__
 106:../src/ir_sensor.c **** 		prevBaselines[dir] = ir_sense_baseline[dir]; //zeroing the baseline array.
 568               		.loc 1 106 0 discriminator 3
 569 0048 80E0      		ldi r24,hi8(ir_sense_baseline+12)
 570 004a E030      		cpi r30,lo8(ir_sense_baseline+12)
 571 004c F807      		cpc r31,r24
 572 004e 01F4      		brne .L28
 573               	.LBE308:
 110:../src/ir_sensor.c **** 	for(uint8_t dir=0;dir<6;dir++){
 574               		.loc 1 110 0
 575 0050 6DE0      		ldi r22,lo8(13)
 576 0052 80E0      		ldi r24,lo8(ir_sense_baseline)
 577 0054 90E0      		ldi r25,hi8(ir_sense_baseline)
 578 0056 0E94 0000 		call get_ir_sensors
 579               	.LVL43:
 580 005a 00C0      		rjmp .L31
 581               	.LVL44:
 582               	.L30:
 583               	.LBB309:
 112:../src/ir_sensor.c **** 	}
 584               		.loc 1 112 0 discriminator 3
 585 005c 9595      		asr r25
 586 005e 8795      		ror r24
 587 0060 F701      		movw r30,r14
 588 0062 8193      		st Z+,r24
 589 0064 9193      		st Z+,r25
 590 0066 7F01      		movw r14,r30
 111:../src/ir_sensor.c **** 		ir_sense_baseline[dir] = (ir_sense_baseline[dir]+prevBaselines[dir])/2;
 591               		.loc 1 111 0 discriminator 3
 592 0068 F0E0      		ldi r31,lo8(ir_sense_baseline+12)
 593 006a EF16      		cp r14,r31
 594 006c F0E0      		ldi r31,hi8(ir_sense_baseline+12)
 595 006e FF06      		cpc r15,r31
 596 0070 01F0      		breq .L34
 597               	.L31:
 112:../src/ir_sensor.c **** 	}
 598               		.loc 1 112 0 discriminator 3
 599 0072 F801      		movw r30,r16
 600 0074 2191      		ld r18,Z+
 601 0076 3191      		ld r19,Z+
 602 0078 8F01      		movw r16,r30
 603 007a F701      		movw r30,r14
 604 007c 8081      		ld r24,Z
 605 007e 9181      		ldd r25,Z+1
 606 0080 820F      		add r24,r18
 607 0082 931F      		adc r25,r19
 608 0084 97FF      		sbrs r25,7
 609 0086 00C0      		rjmp .L30
 610 0088 0196      		adiw r24,1
 611 008a 00C0      		rjmp .L30
 612               	.LVL45:
 613               	.L27:
 614               	.LBE309:
 615               	.LBB310:
 616               	.LBB306:
 617               	.LBB307:
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
 618               		.loc 2 70 0
 619 008c 9FBF      		out __SREG__,r25
 620               		.loc 2 71 0
 621               	.LVL46:
 622               	.L26:
 623               	/* epilogue start */
 624               	.LBE307:
 625               	.LBE306:
 626               	.LBE310:
 117:../src/ir_sensor.c **** 
 627               		.loc 1 117 0
 628 008e 2C96      		adiw r28,12
 629 0090 CDBF      		out __SP_L__,r28
 630 0092 DEBF      		out __SP_H__,r29
 631 0094 DF91      		pop r29
 632 0096 CF91      		pop r28
 633 0098 1F91      		pop r17
 634 009a 0F91      		pop r16
 635 009c FF90      		pop r15
 636 009e EF90      		pop r14
 637 00a0 0895      		ret
 638               	.LVL47:
 639               	.L34:
 640               	.LBB311:
 641               	.LBB312:
 114:../src/ir_sensor.c **** 		hp_ir_block_bm = 0;
 642               		.loc 1 114 0
 643 00a2 8FB7      		in r24,__SREG__
 644               	.LVL48:
 645               	.LBB313:
 646               	.LBB314:
  50:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     return 1;
 647               		.loc 2 50 0
 648               	/* #APP */
 649               	 ;  50 "c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\
 650 00a4 F894      		cli
 651               	 ;  0 "" 2
 652               	.LVL49:
 653               	/* #NOAPP */
 654               	.LBE314:
 655               	.LBE313:
 115:../src/ir_sensor.c **** 	}
 656               		.loc 1 115 0
 657 00a6 1092 0000 		sts hp_ir_block_bm,__zero_reg__
 658               	.LVL50:
 659               	.LBB315:
 660               	.LBB316:
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
 661               		.loc 2 70 0
 662 00aa 8FBF      		out __SREG__,r24
 663               		.loc 2 71 0
 664               	.LVL51:
 665 00ac 00C0      		rjmp .L26
 666               	.LBE316:
 667               	.LBE315:
 668               	.LBE312:
 669               	.LBE311:
 670               		.cfi_endproc
 671               	.LFE64:
 673               		.section	.text.check_collision_values,"ax",@progbits
 674               	.global	check_collision_values
 676               	check_collision_values:
 677               	.LFB67:
 162:../src/ir_sensor.c **** 
 163:../src/ir_sensor.c **** uint8_t check_collisions(){
 164:../src/ir_sensor.c **** 	int16_t meas[6];
 165:../src/ir_sensor.c **** 	uint8_t dirs = 0;
 166:../src/ir_sensor.c **** 	check_collision_values(meas);
 167:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++){
 168:../src/ir_sensor.c **** 		dirs |=  (((meas[i]+ir_sense_baseline[i])>=IR_SENSE_MAX)<<i);
 169:../src/ir_sensor.c **** 	}
 170:../src/ir_sensor.c **** 	return dirs;
 171:../src/ir_sensor.c **** }
 172:../src/ir_sensor.c **** 
 173:../src/ir_sensor.c **** void check_collision_values(int16_t meas[6]){
 678               		.loc 1 173 0
 679               		.cfi_startproc
 680               	.LVL52:
 681 0000 BF92      		push r11
 682               	.LCFI27:
 683               		.cfi_def_cfa_offset 4
 684               		.cfi_offset 11, -3
 685 0002 CF92      		push r12
 686               	.LCFI28:
 687               		.cfi_def_cfa_offset 5
 688               		.cfi_offset 12, -4
 689 0004 DF92      		push r13
 690               	.LCFI29:
 691               		.cfi_def_cfa_offset 6
 692               		.cfi_offset 13, -5
 693 0006 EF92      		push r14
 694               	.LCFI30:
 695               		.cfi_def_cfa_offset 7
 696               		.cfi_offset 14, -6
 697 0008 FF92      		push r15
 698               	.LCFI31:
 699               		.cfi_def_cfa_offset 8
 700               		.cfi_offset 15, -7
 701 000a 0F93      		push r16
 702               	.LCFI32:
 703               		.cfi_def_cfa_offset 9
 704               		.cfi_offset 16, -8
 705 000c 1F93      		push r17
 706               	.LCFI33:
 707               		.cfi_def_cfa_offset 10
 708               		.cfi_offset 17, -9
 709 000e CF93      		push r28
 710               	.LCFI34:
 711               		.cfi_def_cfa_offset 11
 712               		.cfi_offset 28, -10
 713 0010 DF93      		push r29
 714               	.LCFI35:
 715               		.cfi_def_cfa_offset 12
 716               		.cfi_offset 29, -11
 717 0012 CDB7      		in r28,__SP_L__
 718 0014 DEB7      		in r29,__SP_H__
 719               	.LCFI36:
 720               		.cfi_def_cfa_register 28
 721 0016 6897      		sbiw r28,24
 722               	.LCFI37:
 723               		.cfi_def_cfa_offset 36
 724 0018 CDBF      		out __SP_L__,r28
 725 001a DEBF      		out __SP_H__,r29
 726               	/* prologue: function */
 727               	/* frame size = 24 */
 728               	/* stack size = 33 */
 729               	.L__stack_usage = 33
 730 001c B82E      		mov r11,r24
 731 001e 092F      		mov r16,r25
 174:../src/ir_sensor.c **** 	int16_t baseline_meas[6];
 175:../src/ir_sensor.c **** 	int16_t measured_vals[6];
 176:../src/ir_sensor.c **** 	//uint8_t dirs=0;
 177:../src/ir_sensor.c **** 	if(ir_is_busy(ALL_DIRS)<1){
 732               		.loc 1 177 0
 733 0020 8FE3      		ldi r24,lo8(63)
 734               	.LVL53:
 735 0022 0E94 0000 		call ir_is_busy
 736               	.LVL54:
 737 0026 8823      		tst r24
 738 0028 01F4      		brne .+2
 739 002a 00C0      		rjmp .L44
 740               	.LVL55:
 741               	.LBB317:
 178:../src/ir_sensor.c **** 		printf_P(PSTR("IR Hardware busy, probably sending a message? Can't check collisions.\r\n"));
 179:../src/ir_sensor.c **** 		return;
 180:../src/ir_sensor.c **** 	}
 181:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++) ir_rxtx[i].status = IR_STATUS_BUSY_bm;	
 742               		.loc 1 181 0
 743 002c 81E0      		ldi r24,lo8(1)
 744 002e 8093 0000 		sts ir_rxtx+56,r24
 745               	.LVL56:
 746 0032 8093 0000 		sts ir_rxtx+113,r24
 747               	.LVL57:
 748 0036 8093 0000 		sts ir_rxtx+170,r24
 749               	.LVL58:
 750 003a 8093 0000 		sts ir_rxtx+227,r24
 751               	.LVL59:
 752 003e 8093 0000 		sts ir_rxtx+284,r24
 753               	.LVL60:
 754 0042 8093 0000 		sts ir_rxtx+341,r24
 755               	.LVL61:
 756               	.LBE317:
 757               	.LBB318:
 758               	.LBB319:
 759               		.file 3 "../include/ir_led.h"
   1:../include/ir_led.h **** /** \file *********************************************************************
   2:../include/ir_led.h ****  * Low level sensing functions using IR channels.
   3:../include/ir_led.h ****  * Note that there is no IR communication code in this file.
   4:../include/ir_led.h ****  *****************************************************************************/
   5:../include/ir_led.h **** #pragma once
   6:../include/ir_led.h **** 
   7:../include/ir_led.h **** #include <avr/io.h>
   8:../include/ir_led.h **** #include "scheduler.h"
   9:../include/ir_led.h **** #include "i2c.h"
  10:../include/ir_led.h **** 
  11:../include/ir_led.h **** #define ALL_EMITTERS_CARWAV_bm (PIN0_bm | PIN1_bm | PIN4_bm | PIN5_bm | PIN6_bm | PIN7_bm)
  12:../include/ir_led.h **** 
  13:../include/ir_led.h **** #define IR_POWER_ADDR_A 0x2C
  14:../include/ir_led.h **** #define IR_POWER_ADDR_B 0x2E
  15:../include/ir_led.h **** 
  16:../include/ir_led.h **** uint16_t curr_ir_power;
  17:../include/ir_led.h **** 
  18:../include/ir_led.h **** void ir_led_init(void);
  19:../include/ir_led.h **** void set_all_ir_powers(uint16_t power);
  20:../include/ir_led.h **** void ir_led_on(uint8_t direction);
  21:../include/ir_led.h **** void ir_led_off(uint8_t direction);
  22:../include/ir_led.h **** inline uint16_t get_all_ir_powers(void){ return curr_ir_power; }
 760               		.loc 3 22 0
 761 0046 C090 0000 		lds r12,curr_ir_power
 762 004a D090 0000 		lds r13,curr_ir_power+1
 763               	.LBE319:
 764               	.LBE318:
 182:../src/ir_sensor.c **** 	uint16_t curr_power = get_all_ir_powers();
 183:../src/ir_sensor.c **** 	set_all_ir_powers(256);
 765               		.loc 1 183 0
 766 004e 80E0      		ldi r24,0
 767 0050 91E0      		ldi r25,lo8(1)
 768 0052 0E94 0000 		call set_all_ir_powers
 769               	.LVL62:
 184:../src/ir_sensor.c **** 	get_ir_sensors(baseline_meas, 5);
 770               		.loc 1 184 0
 771 0056 7E01      		movw r14,r28
 772 0058 8DE0      		ldi r24,13
 773 005a E80E      		add r14,r24
 774 005c F11C      		adc r15,__zero_reg__
 775 005e 65E0      		ldi r22,lo8(5)
 776 0060 C701      		movw r24,r14
 777 0062 0E94 0000 		call get_ir_sensors
 778               	.LVL63:
 779               	.LBB320:
 185:../src/ir_sensor.c **** 	//printf("Coll    base: ");
 186:../src/ir_sensor.c **** 	//for(uint8_t i=0;i<6;i++) printf("%4d ", baseline_meas[i]);
 187:../src/ir_sensor.c **** 	//printf("\r\n");
 188:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++) ir_led_on(i);
 780               		.loc 1 188 0
 781 0066 10E0      		ldi r17,0
 782               	.LVL64:
 783               	.L38:
 784               		.loc 1 188 0 is_stmt 0 discriminator 3
 785 0068 812F      		mov r24,r17
 786 006a 0E94 0000 		call ir_led_on
 787               	.LVL65:
 788 006e 1F5F      		subi r17,lo8(-(1))
 789               	.LVL66:
 790 0070 1630      		cpi r17,lo8(6)
 791 0072 01F4      		brne .L38
 792               	.LVL67:
 793               	.LBE320:
 794               	.LBB321:
 795               	.LBB322:
 796               	.LBB323:
 797               	.LBB324:
 798               		.file 4 "../include/delay_x.h"
   1:../include/delay_x.h **** /*! \file *********************************************************************
   2:../include/delay_x.h ****   delay_x.h
   3:../include/delay_x.h **** 
   4:../include/delay_x.h ****   Accurate delays ranging from a single CPU cycle up to
   5:../include/delay_x.h ****   more than 500 second (e.g. with 8MHz device):
   6:../include/delay_x.h **** 
   7:../include/delay_x.h ****   The idea for the functions below was heavily inspired by the
   8:../include/delay_x.h ****   file <avr/delay.h> which is part of the excellent WinAVR
   9:../include/delay_x.h ****   distribution. Therefore, thanks to Marek Michalkiewicz and
  10:../include/delay_x.h ****   Joerg Wunsch.
  11:../include/delay_x.h **** 
  12:../include/delay_x.h ****   The idea is to have the GCC preprocessor handle all calculations
  13:../include/delay_x.h ****   necessary for determining the exact implementation of a delay
  14:../include/delay_x.h ****   algorithm. The implementation itself is then inlined into the
  15:../include/delay_x.h ****   user code.
  16:../include/delay_x.h ****   In this way it is possible to always get the code size optimized
  17:../include/delay_x.h ****   delay implementation.
  18:../include/delay_x.h **** 
  19:../include/delay_x.h **** \verbatim
  20:../include/delay_x.h ****   !!======================================================!!
  21:../include/delay_x.h ****   !! Requires compile time constants for the delay        !!
  22:../include/delay_x.h ****   !! Requires compiler optimization                       !!
  23:../include/delay_x.h ****   !!======================================================!!
  24:../include/delay_x.h **** \endverbatim
  25:../include/delay_x.h **** 
  26:../include/delay_x.h ****    Copyright (c) 2005, Hans-Juergen Heinrichs
  27:../include/delay_x.h ****    All rights reserved.
  28:../include/delay_x.h **** 
  29:../include/delay_x.h ****    Redistribution and use in source and binary forms, with or without
  30:../include/delay_x.h ****    modification, are permitted provided that the following conditions are met:
  31:../include/delay_x.h **** 
  32:../include/delay_x.h ****    * Redistributions of source code must retain the above copyright
  33:../include/delay_x.h ****      notice, this list of conditions and the following disclaimer.
  34:../include/delay_x.h **** 
  35:../include/delay_x.h ****    * Redistributions in binary form must reproduce the above copyright
  36:../include/delay_x.h ****      notice, this list of conditions and the following disclaimer in
  37:../include/delay_x.h ****      the documentation and/or other materials provided with the
  38:../include/delay_x.h ****      distribution.
  39:../include/delay_x.h **** 
  40:../include/delay_x.h ****    * Neither the name of the copyright holders nor the names of
  41:../include/delay_x.h ****      contributors may be used to endorse or promote products derived
  42:../include/delay_x.h ****      from this software without specific prior written permission.
  43:../include/delay_x.h **** 
  44:../include/delay_x.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  45:../include/delay_x.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  46:../include/delay_x.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  47:../include/delay_x.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  48:../include/delay_x.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  49:../include/delay_x.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  50:../include/delay_x.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  51:../include/delay_x.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  52:../include/delay_x.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  53:../include/delay_x.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  54:../include/delay_x.h ****   POSSIBILITY OF SUCH DAMAGE.
  55:../include/delay_x.h ****  *****************************************************************************/
  56:../include/delay_x.h **** #pragma once
  57:../include/delay_x.h **** 
  58:../include/delay_x.h **** #include <inttypes.h>
  59:../include/delay_x.h **** 
  60:../include/delay_x.h **** #ifndef F_CPU
  61:../include/delay_x.h **** # warning "Macro F_CPU must be defined"
  62:../include/delay_x.h **** #endif
  63:../include/delay_x.h **** 
  64:../include/delay_x.h **** 
  65:../include/delay_x.h **** /*
  66:../include/delay_x.h ****  *
  67:../include/delay_x.h ****  *   _ d e l a y _ n s (double __ns)
  68:../include/delay_x.h ****  *   _ d e l a y _ u s (double __us)
  69:../include/delay_x.h ****  *   _ d e l a y _ m s (double __ms)
  70:../include/delay_x.h ****  *   _ d e l a y _ s   (double __s)
  71:../include/delay_x.h ****  *
  72:../include/delay_x.h ****  *   Perform a very exact delay with a resolution as accurate as a
  73:../include/delay_x.h ****  *   single CPU clock (the macro F_CPU is supposed to be defined to a
  74:../include/delay_x.h ****  *   constant defining the CPU clock frequency in Hertz).
  75:../include/delay_x.h ****  *
  76:../include/delay_x.h ****  */
  77:../include/delay_x.h **** #define busy_delay_ns(__ns)     _delay_cycles( (double)(F_CPU)*((double)__ns)/1.0e9 + 0.5 )
  78:../include/delay_x.h **** #define busy_delay_us(__us)     _delay_cycles( (double)(F_CPU)*((double)__us)/1.0e6 + 0.5 )
  79:../include/delay_x.h **** #define busy_delay_ms(__ms)     _delay_cycles( (double)(F_CPU)*((double)__ms)/1.0e3 + 0.5 )
  80:../include/delay_x.h **** #define busy_delay_s(  __s)     _delay_cycles( (double)(F_CPU)*((double)__s )/1.0e0 + 0.5 )
  81:../include/delay_x.h **** 
  82:../include/delay_x.h **** /* ==========================================================================*/
  83:../include/delay_x.h **** 
  84:../include/delay_x.h **** /*
  85:../include/delay_x.h ****  * Forward declaration for all functions with attribute
  86:../include/delay_x.h ****  * 'always_inline' enforces GCC to inline the code (even
  87:../include/delay_x.h ****  * if it would be better not to do so from optimization
  88:../include/delay_x.h ****  * perspective).
  89:../include/delay_x.h ****  * Without this attribute GCC is free to implement
  90:../include/delay_x.h ****  * inline code or not (using the keyword 'inline'
  91:../include/delay_x.h ****  * alone is not sufficient).
  92:../include/delay_x.h ****  *
  93:../include/delay_x.h ****  */
  94:../include/delay_x.h **** static __inline__ void _NOP1( void) __attribute__((always_inline));
  95:../include/delay_x.h **** static __inline__ void _NOP2( void) __attribute__((always_inline));
  96:../include/delay_x.h **** static __inline__ void _NOP3( void) __attribute__((always_inline));
  97:../include/delay_x.h **** static __inline__ void _NOP4( void) __attribute__((always_inline));
  98:../include/delay_x.h **** static __inline__ void _NOP5( void) __attribute__((always_inline));
  99:../include/delay_x.h **** static __inline__ void _NOP6( void) __attribute__((always_inline));
 100:../include/delay_x.h **** static __inline__ void _NOP7( void) __attribute__((always_inline));
 101:../include/delay_x.h **** static __inline__ void _NOP8( void) __attribute__((always_inline));
 102:../include/delay_x.h **** static __inline__ void _NOP9( void) __attribute__((always_inline));
 103:../include/delay_x.h **** static __inline__ void _NOP10(void) __attribute__((always_inline));
 104:../include/delay_x.h **** static __inline__ void _NOP11(void) __attribute__((always_inline));
 105:../include/delay_x.h **** static __inline__ void _NOP12(void) __attribute__((always_inline));
 106:../include/delay_x.h **** 
 107:../include/delay_x.h **** static __inline__ void _delay_loop_3(  uint32_t) __attribute__((always_inline));
 108:../include/delay_x.h **** static __inline__ void _delay_loop_1_x( uint8_t) __attribute__((always_inline));
 109:../include/delay_x.h **** static __inline__ void _delay_loop_2_x(uint16_t) __attribute__((always_inline));
 110:../include/delay_x.h **** static __inline__ void _delay_loop_3_x(uint32_t) __attribute__((always_inline));
 111:../include/delay_x.h **** 
 112:../include/delay_x.h **** static __inline__ void _delay_cycles(const double) __attribute__((always_inline));
 113:../include/delay_x.h **** 
 114:../include/delay_x.h **** 
 115:../include/delay_x.h **** /*
 116:../include/delay_x.h ****  * _ N O P x ( void )
 117:../include/delay_x.h ****  *
 118:../include/delay_x.h ****  * Code size optimized NOPs - not using any registers
 119:../include/delay_x.h ****  *
 120:../include/delay_x.h ****  * These NOPs will be used for very short delays where
 121:../include/delay_x.h ****  * it is more code efficient than executing loops.
 122:../include/delay_x.h ****  *
 123:../include/delay_x.h ****  */
 124:../include/delay_x.h **** static __inline__ void _NOP1 (void) { __asm__ volatile ( "nop    " "\n\t" ); }
 125:../include/delay_x.h **** static __inline__ void _NOP2 (void) { __asm__ volatile ( "rjmp 1f" "\n\t"  "1:" "\n\t" ); }
 126:../include/delay_x.h **** static __inline__ void _NOP3 (void) { __asm__ volatile ( "lpm    " "\n\t" ); }
 127:../include/delay_x.h **** static __inline__ void _NOP4 (void) { _NOP3(); _NOP1(); }
 128:../include/delay_x.h **** static __inline__ void _NOP5 (void) { _NOP3(); _NOP2(); }
 129:../include/delay_x.h **** static __inline__ void _NOP6 (void) { _NOP3(); _NOP3(); }
 130:../include/delay_x.h **** static __inline__ void _NOP7 (void) { _NOP3(); _NOP3(); _NOP1(); }
 131:../include/delay_x.h **** static __inline__ void _NOP8 (void) { _NOP3(); _NOP3(); _NOP2(); }
 132:../include/delay_x.h **** static __inline__ void _NOP9 (void) { _NOP3(); _NOP3(); _NOP3(); }
 133:../include/delay_x.h **** static __inline__ void _NOP10(void) { _NOP3(); _NOP3(); _NOP3(); _NOP1(); }
 134:../include/delay_x.h **** static __inline__ void _NOP11(void) { _NOP3(); _NOP3(); _NOP3(); _NOP2(); }
 135:../include/delay_x.h **** static __inline__ void _NOP12(void) { _NOP3(); _NOP3(); _NOP3(); _NOP3(); }
 136:../include/delay_x.h **** 
 137:../include/delay_x.h **** 
 138:../include/delay_x.h **** 
 139:../include/delay_x.h **** /*
 140:../include/delay_x.h ****  *  _ d e l a y _ l o o p _ 3( uint32_t __count )
 141:../include/delay_x.h ****  *
 142:../include/delay_x.h ****  * This delay loop is not used in the code below: It is
 143:../include/delay_x.h ****  * a supplement to the _delay_loop_1() and _delay_loop_2()
 144:../include/delay_x.h ****  * within standard WinAVR <arv/delay.h> giving a wider
 145:../include/delay_x.h ****  * (32 bit) delay range.
 146:../include/delay_x.h ****  *
 147:../include/delay_x.h ****  */
 148:../include/delay_x.h **** static __inline__ void
 149:../include/delay_x.h **** _delay_loop_3( uint32_t __count )
 150:../include/delay_x.h **** {
 151:../include/delay_x.h ****     __asm__ volatile (
 152:../include/delay_x.h ****         "1: sbiw %A0,1" "\n\t"
 153:../include/delay_x.h ****         "sbc %C0,__zero_reg__" "\n\t"
 154:../include/delay_x.h ****         "sbc %D0,__zero_reg__" "\n\t"
 155:../include/delay_x.h ****         "brne 1b"
 156:../include/delay_x.h ****         : "=w" (__count)
 157:../include/delay_x.h ****         : "0" (__count)
 158:../include/delay_x.h ****     );
 159:../include/delay_x.h **** }
 160:../include/delay_x.h **** 
 161:../include/delay_x.h **** 
 162:../include/delay_x.h **** /*
 163:../include/delay_x.h ****  *  _ d e l a y _ l o o p _ 1 _ x( uint8_t __n )
 164:../include/delay_x.h ****  *  _ d e l a y _ l o o p _ 2 _ x( uint16_t  __n )
 165:../include/delay_x.h ****  *  _ d e l a y _ l o o p _ 3 _ x( uint32_t __n )
 166:../include/delay_x.h ****  *
 167:../include/delay_x.h ****  *  These delay loops always have exactly 4(8) cycles per loop.
 168:../include/delay_x.h ****  *  They use a 8/16/32 bit register counter respectively.
 169:../include/delay_x.h ****  *
 170:../include/delay_x.h ****  */
 171:../include/delay_x.h **** static __inline__ void      /* exactly 4 cycles/loop, max 2**8 loops */
 172:../include/delay_x.h **** _delay_loop_1_x( uint8_t __n )
 173:../include/delay_x.h **** {                                               /* cycles per loop      */
 174:../include/delay_x.h ****     __asm__ volatile (                          /* __n..one        zero */
 175:../include/delay_x.h ****         "1: dec  %0"   "\n\t"                   /*    1             1   */
 176:../include/delay_x.h ****         "   breq 2f"   "\n\t"                   /*    1             2   */
 177:../include/delay_x.h ****         "2: brne 1b"   "\n\t"                   /*    2             1   */
 178:../include/delay_x.h ****         : "=r" (__n)                            /*  -----         ----- */
 179:../include/delay_x.h ****         : "0" (__n)                             /*    4             4   */
 180:../include/delay_x.h ****     );
 181:../include/delay_x.h **** }
 182:../include/delay_x.h **** 
 183:../include/delay_x.h **** static __inline__ void      /* exactly 4 cycles/loop, max 2**16 loops */
 184:../include/delay_x.h **** _delay_loop_2_x( uint16_t __n )
 185:../include/delay_x.h **** {                                               /* cycles per loop      */
 186:../include/delay_x.h ****     __asm__ volatile (                          /* __n..one        zero */
 799               		.loc 4 186 0 is_stmt 1
 800 0074 8FEC      		ldi r24,lo8(-49)
 801 0076 97E0      		ldi r25,lo8(7)
 802               	/* #APP */
 803               	 ;  186 "../include/delay_x.h" 1
 804 0078 0197      		1: sbiw r24,1
 805 007a 01F4      		   brne 1b  
 806 007c 0000      		   nop      
 807               		
 808               	 ;  0 "" 2
 809               	.LVL68:
 810               	/* #NOAPP */
 811               	.LBE324:
 812               	.LBE323:
 813               	.LBB325:
 814               	.LBB326:
 125:../include/delay_x.h **** static __inline__ void _NOP3 (void) { __asm__ volatile ( "lpm    " "\n\t" ); }
 815               		.loc 4 125 0
 816               	/* #APP */
 817               	 ;  125 "../include/delay_x.h" 1
 818 007e 00C0      		rjmp 1f
 819               		1:
 820               		
 821               	 ;  0 "" 2
 822               	.LVL69:
 823               	/* #NOAPP */
 824               	.LBE326:
 825               	.LBE325:
 826               	.LBE322:
 827               	.LBE321:
 189:../src/ir_sensor.c **** 	busy_delay_us(250);	
 190:../src/ir_sensor.c **** 	get_ir_sensors(measured_vals, 5);
 828               		.loc 1 190 0
 829 0080 65E0      		ldi r22,lo8(5)
 830 0082 CE01      		movw r24,r28
 831 0084 0196      		adiw r24,1
 832 0086 0E94 0000 		call get_ir_sensors
 833               	.LVL70:
 834               	.LBB327:
 191:../src/ir_sensor.c **** 	//printf("Coll results: ");
 192:../src/ir_sensor.c **** 	//for(uint8_t i=0;i<6;i++) printf("%4d ", measured_vals[i]);
 193:../src/ir_sensor.c **** 	//printf("\r\n");
 194:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++) ir_led_off(i);
 835               		.loc 1 194 0
 836 008a 10E0      		ldi r17,0
 837               	.LVL71:
 838               	.L39:
 839               		.loc 1 194 0 is_stmt 0 discriminator 3
 840 008c 812F      		mov r24,r17
 841 008e 0E94 0000 		call ir_led_off
 842               	.LVL72:
 843 0092 1F5F      		subi r17,lo8(-(1))
 844               	.LVL73:
 845 0094 1630      		cpi r17,lo8(6)
 846 0096 01F4      		brne .L39
 847 0098 FE01      		movw r30,r28
 848 009a 3196      		adiw r30,1
 849 009c 9701      		movw r18,r14
 850 009e 6B2D      		mov r22,r11
 851 00a0 702F      		mov r23,r16
 852               	.L40:
 853               	.LBE327:
 854               	.LBB328:
 195:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++){
 196:../src/ir_sensor.c **** 		meas[i] = (measured_vals[i]-baseline_meas[i]);
 855               		.loc 1 196 0 is_stmt 1 discriminator 3
 856 00a2 8191      		ld r24,Z+
 857 00a4 9191      		ld r25,Z+
 858 00a6 D901      		movw r26,r18
 859 00a8 4D91      		ld r20,X+
 860 00aa 5D91      		ld r21,X+
 861 00ac 9D01      		movw r18,r26
 862 00ae 841B      		sub r24,r20
 863 00b0 950B      		sbc r25,r21
 864 00b2 DB01      		movw r26,r22
 865 00b4 8D93      		st X+,r24
 866 00b6 9D93      		st X+,r25
 867 00b8 BD01      		movw r22,r26
 868               	.LVL74:
 195:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++){
 869               		.loc 1 195 0 discriminator 3
 870 00ba EE15      		cp r30,r14
 871 00bc FF05      		cpc r31,r15
 872 00be 01F4      		brne .L40
 873               	.LBE328:
 197:../src/ir_sensor.c **** 	}
 198:../src/ir_sensor.c **** 	set_all_ir_powers(curr_power);
 874               		.loc 1 198 0
 875 00c0 C601      		movw r24,r12
 876 00c2 0E94 0000 		call set_all_ir_powers
 877               	.LVL75:
 878               	.LBB329:
 199:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++) ir_rxtx[i].status = 0;		
 879               		.loc 1 199 0
 880 00c6 1092 0000 		sts ir_rxtx+56,__zero_reg__
 881               	.LVL76:
 882 00ca 1092 0000 		sts ir_rxtx+113,__zero_reg__
 883               	.LVL77:
 884 00ce 1092 0000 		sts ir_rxtx+170,__zero_reg__
 885               	.LVL78:
 886 00d2 1092 0000 		sts ir_rxtx+227,__zero_reg__
 887               	.LVL79:
 888 00d6 1092 0000 		sts ir_rxtx+284,__zero_reg__
 889               	.LVL80:
 890 00da 1092 0000 		sts ir_rxtx+341,__zero_reg__
 891               	.LVL81:
 892               	.L35:
 893               	/* epilogue start */
 894               	.LBE329:
 200:../src/ir_sensor.c **** }	...
 895               		.loc 1 200 0
 896 00de 6896      		adiw r28,24
 897 00e0 CDBF      		out __SP_L__,r28
 898 00e2 DEBF      		out __SP_H__,r29
 899 00e4 DF91      		pop r29
 900 00e6 CF91      		pop r28
 901 00e8 1F91      		pop r17
 902 00ea 0F91      		pop r16
 903 00ec FF90      		pop r15
 904 00ee EF90      		pop r14
 905 00f0 DF90      		pop r13
 906 00f2 CF90      		pop r12
 907 00f4 BF90      		pop r11
 908 00f6 0895      		ret
 909               	.L44:
 178:../src/ir_sensor.c **** 		printf_P(PSTR("IR Hardware busy, probably sending a message? Can't check collisions.\r\n"));
 910               		.loc 1 178 0
 911 00f8 80E0      		ldi r24,lo8(__c.5308)
 912 00fa 90E0      		ldi r25,hi8(__c.5308)
 913 00fc 9F93      		push r25
 914 00fe 8F93      		push r24
 915 0100 0E94 0000 		call printf_P
 916               	.LVL82:
 179:../src/ir_sensor.c **** 		return;
 917               		.loc 1 179 0
 918 0104 0F90      		pop __tmp_reg__
 919 0106 0F90      		pop __tmp_reg__
 920 0108 00C0      		rjmp .L35
 921               		.cfi_endproc
 922               	.LFE67:
 924               		.section	.text.check_collisions,"ax",@progbits
 925               	.global	check_collisions
 927               	check_collisions:
 928               	.LFB66:
 163:../src/ir_sensor.c **** uint8_t check_collisions(){
 929               		.loc 1 163 0
 930               		.cfi_startproc
 931 0000 CF93      		push r28
 932               	.LCFI38:
 933               		.cfi_def_cfa_offset 4
 934               		.cfi_offset 28, -3
 935 0002 DF93      		push r29
 936               	.LCFI39:
 937               		.cfi_def_cfa_offset 5
 938               		.cfi_offset 29, -4
 939 0004 CDB7      		in r28,__SP_L__
 940 0006 DEB7      		in r29,__SP_H__
 941               	.LCFI40:
 942               		.cfi_def_cfa_register 28
 943 0008 2C97      		sbiw r28,12
 944               	.LCFI41:
 945               		.cfi_def_cfa_offset 17
 946 000a CDBF      		out __SP_L__,r28
 947 000c DEBF      		out __SP_H__,r29
 948               	/* prologue: function */
 949               	/* frame size = 12 */
 950               	/* stack size = 14 */
 951               	.L__stack_usage = 14
 952               	.LVL83:
 166:../src/ir_sensor.c **** 	check_collision_values(meas);
 953               		.loc 1 166 0
 954 000e CE01      		movw r24,r28
 955 0010 0196      		adiw r24,1
 956 0012 0E94 0000 		call check_collision_values
 957               	.LVL84:
 958 0016 FE01      		movw r30,r28
 959 0018 3196      		adiw r30,1
 960 001a A0E0      		ldi r26,lo8(ir_sense_baseline)
 961 001c B0E0      		ldi r27,hi8(ir_sense_baseline)
 962 001e 40E0      		ldi r20,0
 963 0020 50E0      		ldi r21,0
 165:../src/ir_sensor.c **** 	uint8_t dirs = 0;
 964               		.loc 1 165 0
 965 0022 80E0      		ldi r24,0
 966               	.LVL85:
 967               	.L47:
 968               	.LBB330:
 168:../src/ir_sensor.c **** 		dirs |=  (((meas[i]+ir_sense_baseline[i])>=IR_SENSE_MAX)<<i);
 969               		.loc 1 168 0 discriminator 3
 970 0024 6191      		ld r22,Z+
 971 0026 7191      		ld r23,Z+
 972 0028 2D91      		ld r18,X+
 973 002a 3D91      		ld r19,X+
 974 002c 620F      		add r22,r18
 975 002e 731F      		adc r23,r19
 976 0030 21E0      		ldi r18,lo8(1)
 977 0032 30E0      		ldi r19,0
 978 0034 6F3F      		cpi r22,-1
 979 0036 7740      		sbci r23,7
 980 0038 04F4      		brge .L46
 981 003a 20E0      		ldi r18,0
 982 003c 30E0      		ldi r19,0
 983               	.L46:
 984 003e 042E      		mov r0,r20
 985 0040 00C0      		rjmp 2f
 986               		1:
 987 0042 220F      		lsl r18
 988               		2:
 989 0044 0A94      		dec r0
 990 0046 02F4      		brpl 1b
 991 0048 822B      		or r24,r18
 992               	.LVL86:
 993 004a 4F5F      		subi r20,-1
 994 004c 5F4F      		sbci r21,-1
 995               	.LVL87:
 167:../src/ir_sensor.c **** 	for(uint8_t i=0;i<6;i++){
 996               		.loc 1 167 0 discriminator 3
 997 004e 4630      		cpi r20,6
 998 0050 5105      		cpc r21,__zero_reg__
 999 0052 01F4      		brne .L47
 1000               	/* epilogue start */
 1001               	.LBE330:
 171:../src/ir_sensor.c **** }
 1002               		.loc 1 171 0
 1003 0054 2C96      		adiw r28,12
 1004 0056 CDBF      		out __SP_L__,r28
 1005 0058 DEBF      		out __SP_H__,r29
 1006 005a DF91      		pop r29
 1007 005c CF91      		pop r28
 1008 005e 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE66:
 1012               		.section	.progmem.data.__c.5308,"a",@progbits
 1015               	__c.5308:
 1016 0000 4952 2048 		.string	"IR Hardware busy, probably sending a message? Can't check collisions.\r\n"
 1016      6172 6477 
 1016      6172 6520 
 1016      6275 7379 
 1016      2C20 7072 
 1017               		.section	.bss.ir_sense_baseline,"aw",@nobits
 1020               	ir_sense_baseline:
 1021 0000 0000 0000 		.zero	12
 1021      0000 0000 
 1021      0000 0000 
 1022               	.global	mux_sensor_selectors
 1023               		.section	.rodata.mux_sensor_selectors,"a",@progbits
 1026               	mux_sensor_selectors:
 1027 0000 28        		.byte	40
 1028 0001 30        		.byte	48
 1029 0002 38        		.byte	56
 1030 0003 20        		.byte	32
 1031 0004 10        		.byte	16
 1032 0005 18        		.byte	24
 1033               		.comm	cmd_sender_dir,1,1
 1034               		.comm	cmd_arrival_dir,1,1
 1035               		.comm	cmd_sender_id,2,1
 1036               		.comm	cmd_arrival_time,4,1
 1037               		.comm	user_facing_messages_ovf,1,1
 1038               		.comm	num_waiting_msgs,1,1
 1039               		.comm	hp_ir_block_bm,1,1
 1040               		.comm	msg_node,294,1
 1041               		.comm	ir_rxtx,342,1
 1042               		.comm	obsStart,2,1
 1043               		.comm	mm_per_kilostep,16,1
 1044               		.comm	motor_adjusts,48,1
 1045               		.comm	rnbProcessingFlag,1,1
 1046               		.comm	rnbCmdSentTime,4,1
 1047               		.comm	rnbCmdID,2,1
 1048               		.comm	rnb_updated,1,1
 1049               		.comm	last_good_rnb,8,1
 1050               		.comm	curr_ir_power,2,1
 1051               		.comm	twi,2,1
 1052               		.comm	twiMaster,25,1
 1053               		.section	.bss.task_storage_arr,"aw",@nobits
 1056               	task_storage_arr:
 1057 0000 0000 0000 		.zero	140
 1057      0000 0000 
 1057      0000 0000 
 1057      0000 0000 
 1057      0000 0000 
 1058               		.comm	task_executing,1,1
 1059               		.comm	num_tasks,1,1
 1060               		.comm	task_list,2,1
 1061               		.comm	rtc_epoch,2,1
 1062               		.comm	droplet_ID,2,1
 1063               		.text
 1064               	.Letext0:
 1065               		.file 5 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 1066               		.file 6 "C:/Program Files (x86)/Atmel/Studio/7.0/Packs/atmel/XMEGAA_DFP/1.1.68/include/avr/iox128a
 1067               		.file 7 "../include/droplet_base.h"
 1068               		.file 8 "../include/scheduler.h"
 1069               		.file 9 "../include/i2c.h"
 1070               		.file 10 "../include/range_algs.h"
 1071               		.file 11 "../include/firefly_sync.h"
 1072               		.file 12 "../include/ir_comm.h"
 1073               		.file 13 "../include/motor.h"
 1074               		.file 14 "../include/rgb_sensor.h"
 1075               		.file 15 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\i
DEFINED SYMBOLS
                            *ABS*:00000000 ir_sensor.c
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:2      *ABS*:0000003e __SP_H__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:3      *ABS*:0000003d __SP_L__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:4      *ABS*:0000003f __SREG__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:6      *ABS*:00000034 __CCP__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:7      *ABS*:00000000 __tmp_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:8      *ABS*:00000001 __zero_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:15     .text.ir_sensor_init:00000000 ir_sensor_init
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:1020   .bss.ir_sense_baseline:00000000 ir_sense_baseline
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:455    .text.initialize_ir_baselines:00000000 initialize_ir_baselines
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:475    .text.update_ir_baselines:00000000 update_ir_baselines
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:120    .text.get_ir_sensors:00000000 get_ir_sensors
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:1026   .rodata.mux_sensor_selectors:00000000 mux_sensor_selectors
                            *COM*:00000001 hp_ir_block_bm
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:676    .text.check_collision_values:00000000 check_collision_values
                            *COM*:00000156 ir_rxtx
                            *COM*:00000002 curr_ir_power
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:1015   .progmem.data.__c.5308:00000000 __c.5308
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:927    .text.check_collisions:00000000 check_collisions
                            *COM*:00000001 cmd_sender_dir
                            *COM*:00000001 cmd_arrival_dir
                            *COM*:00000002 cmd_sender_id
                            *COM*:00000004 cmd_arrival_time
                            *COM*:00000001 user_facing_messages_ovf
                            *COM*:00000001 num_waiting_msgs
                            *COM*:00000126 msg_node
                            *COM*:00000002 obsStart
                            *COM*:00000010 mm_per_kilostep
                            *COM*:00000030 motor_adjusts
                            *COM*:00000001 rnbProcessingFlag
                            *COM*:00000004 rnbCmdSentTime
                            *COM*:00000002 rnbCmdID
                            *COM*:00000001 rnb_updated
                            *COM*:00000008 last_good_rnb
                            *COM*:00000002 twi
                            *COM*:00000019 twiMaster
C:\Users\JOHNK~1\AppData\Local\Temp\ccdP6T1y.s:1056   .bss.task_storage_arr:00000000 task_storage_arr
                            *COM*:00000001 task_executing
                            *COM*:00000001 num_tasks
                            *COM*:00000002 task_list
                            *COM*:00000002 rtc_epoch
                            *COM*:00000002 droplet_ID

UNDEFINED SYMBOLS
schedule_task
schedule_periodic_task
meas_find_median
ir_is_busy
set_all_ir_powers
ir_led_on
ir_led_off
printf_P
__do_copy_data
__do_clear_bss
