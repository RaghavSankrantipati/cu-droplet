   1               		.file	"rgb_sensor.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__CCP__ = 0x34
   7               	__tmp_reg__ = 0
   8               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  11               		.cfi_sections	.debug_frame
  12               		.section	.text.meas_find_median,"ax",@progbits
  13               	.global	meas_find_median
  15               	meas_find_median:
  16               	.LFB41:
  17               		.file 1 "../src/rgb_sensor.c"
   1:../src/rgb_sensor.c **** #include "rgb_sensor.h"
   2:../src/rgb_sensor.c **** #define RGB_SENSE_ADDR 0x29
   3:../src/rgb_sensor.c **** 
   4:../src/rgb_sensor.c **** static const char RGB_SENSE_POWERON_FAILURE[] PROGMEM = "RGB sense power-on failed %u.\r\n";
   5:../src/rgb_sensor.c **** #ifndef AUDIO_DROPLET
   6:../src/rgb_sensor.c **** static int16_t r_baseline, g_baseline, b_baseline;
   7:../src/rgb_sensor.c **** #endif
   8:../src/rgb_sensor.c **** 
   9:../src/rgb_sensor.c **** //typedef enum{
  10:../src/rgb_sensor.c **** 	//R, G, B
  11:../src/rgb_sensor.c **** //} Colors;
  12:../src/rgb_sensor.c **** 
  13:../src/rgb_sensor.c **** typedef union{
  14:../src/rgb_sensor.c **** 	uint32_t i;
  15:../src/rgb_sensor.c **** 	float f;
  16:../src/rgb_sensor.c **** } u;
  17:../src/rgb_sensor.c **** 
  18:../src/rgb_sensor.c **** void rgb_sensor_init()
  19:../src/rgb_sensor.c **** {
  20:../src/rgb_sensor.c **** 	#ifdef AUDIO_DROPLET
  21:../src/rgb_sensor.c **** 		uint8_t power_on_sequence[8] = {0x80, 0x01,  // Write 0x01 to ENABLE register, activating the dev
  22:../src/rgb_sensor.c **** 										0x8F, 0x01,  // Write 0x01 to CONTROL register, setting the gain to x4.
  23:../src/rgb_sensor.c **** 										0x81, 0xD5,	 // Write 0xD5 to ATIME register, setting the integration time to 2.4ms*(256-
  24:../src/rgb_sensor.c **** 										0x80, 0x03};  // Write 0x03 to ENABLE register, activating the ADC (and leaving the oscil
  25:../src/rgb_sensor.c **** 
  26:../src/rgb_sensor.c **** 		uint8_t result = TWI_MasterWrite(RGB_SENSE_ADDR, &(power_on_sequence[0]), 2);
  27:../src/rgb_sensor.c **** 		if(!result)	printf_P(RGB_SENSE_POWERON_FAILURE,1);
  28:../src/rgb_sensor.c **** 		delay_ms(5);
  29:../src/rgb_sensor.c **** 		result = TWI_MasterWrite(RGB_SENSE_ADDR, &(power_on_sequence[2]), 2);
  30:../src/rgb_sensor.c **** 		if(!result)	printf_P(RGB_SENSE_POWERON_FAILURE,2);
  31:../src/rgb_sensor.c **** 		delay_ms(5);
  32:../src/rgb_sensor.c **** 		result = TWI_MasterWrite(RGB_SENSE_ADDR, &(power_on_sequence[4]), 2);
  33:../src/rgb_sensor.c **** 		if(!result)	printf_P(RGB_SENSE_POWERON_FAILURE,3);
  34:../src/rgb_sensor.c **** 		delay_ms(5);
  35:../src/rgb_sensor.c **** 		result = TWI_MasterWrite(RGB_SENSE_ADDR, &(power_on_sequence[6]), 2);
  36:../src/rgb_sensor.c **** 		if(!result)	printf_P(RGB_SENSE_POWERON_FAILURE,4);
  37:../src/rgb_sensor.c **** 		delay_ms(5);
  38:../src/rgb_sensor.c **** 	#else		
  39:../src/rgb_sensor.c **** 		RGB_SENSOR_PORT.DIRCLR = RGB_SENSOR_R_PIN_bm | RGB_SENSOR_G_PIN_bm | RGB_SENSOR_B_PIN_bm;
  40:../src/rgb_sensor.c **** 
  41:../src/rgb_sensor.c **** 		ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
  42:../src/rgb_sensor.c **** 		ADCA.CTRLB = ADC_RESOLUTION_LEFT12BIT_gc | ADC_CONMODE_bm;
  43:../src/rgb_sensor.c **** 		ADCA.PRESCALER = ADC_PRESCALER_DIV256_gc;
  44:../src/rgb_sensor.c **** 		/* When differential input is used, signed mode must be used. (sec. 28.6 of Manual) */
  45:../src/rgb_sensor.c **** 
  46:../src/rgb_sensor.c **** 		ADCA.CH0.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_1X_gc;	//Probably should turn the gai
  47:../src/rgb_sensor.c **** 		ADCA.CH1.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_1X_gc;	//Probably should turn the gai
  48:../src/rgb_sensor.c **** 		ADCA.CH2.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_2X_gc;	//Probably should turn the gai
  49:../src/rgb_sensor.c **** 	
  50:../src/rgb_sensor.c **** 		ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN5_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Red sensor on ADC A 
  51:../src/rgb_sensor.c **** 		ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN6_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Green sensor on ADC 
  52:../src/rgb_sensor.c **** 		ADCA.CH2.MUXCTRL = ADC_CH_MUXPOS_PIN7_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Blue sensor on ADC A
  53:../src/rgb_sensor.c **** 	
  54:../src/rgb_sensor.c **** 		ADCA.CALL = PRODSIGNATURES_ADCACAL0;
  55:../src/rgb_sensor.c **** 		ADCA.CALH = PRODSIGNATURES_ADCACAL1;
  56:../src/rgb_sensor.c **** 
  57:../src/rgb_sensor.c **** 		ADCA.CTRLA = ADC_ENABLE_bm;
  58:../src/rgb_sensor.c **** 	
  59:../src/rgb_sensor.c **** 		//read_color_settings();
  60:../src/rgb_sensor.c **** 	
  61:../src/rgb_sensor.c **** 		delay_us(50);
  62:../src/rgb_sensor.c **** 		const int8_t num_samples = 3;
  63:../src/rgb_sensor.c **** 		get_red_sensor(); get_blue_sensor(); get_green_sensor();
  64:../src/rgb_sensor.c **** 		delay_ms(10);
  65:../src/rgb_sensor.c **** 		int16_t r_avg=0, g_avg=0, b_avg=0;
  66:../src/rgb_sensor.c **** 		for(uint8_t i=0; i<num_samples; i++)
  67:../src/rgb_sensor.c **** 		{
  68:../src/rgb_sensor.c **** 			r_avg+=get_red_sensor();
  69:../src/rgb_sensor.c **** 			g_avg+=get_green_sensor();
  70:../src/rgb_sensor.c **** 			b_avg+=get_blue_sensor();
  71:../src/rgb_sensor.c **** 			delay_ms(10);
  72:../src/rgb_sensor.c **** 			//printf("\r\n");
  73:../src/rgb_sensor.c **** 		}
  74:../src/rgb_sensor.c **** 		r_baseline= r_avg/num_samples;
  75:../src/rgb_sensor.c **** 		g_baseline= g_avg/num_samples;
  76:../src/rgb_sensor.c **** 		b_baseline= b_avg/num_samples;
  77:../src/rgb_sensor.c **** 		//printf("Baselines:\r\n%3d  %3d  %3d\r\n", r_baseline, g_baseline, b_baseline);
  78:../src/rgb_sensor.c **** 		r_baseline = 0;
  79:../src/rgb_sensor.c **** 		g_baseline = 0;
  80:../src/rgb_sensor.c **** 		b_baseline = 0;	
  81:../src/rgb_sensor.c **** 	#endif		
  82:../src/rgb_sensor.c **** }
  83:../src/rgb_sensor.c **** 
  84:../src/rgb_sensor.c **** #ifndef AUDIO_DROPLET
  85:../src/rgb_sensor.c **** 
  86:../src/rgb_sensor.c **** int16_t get_red_sensor(){
  87:../src/rgb_sensor.c **** 	int16_t meas[RGB_MEAS_COUNT];
  88:../src/rgb_sensor.c **** 	int16_t red_val;
  89:../src/rgb_sensor.c **** 	//printf("R: ");
  90:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++){
  91:../src/rgb_sensor.c **** 		ADCA.CH0.CTRL |= ADC_CH_START_bm;
  92:../src/rgb_sensor.c **** 		while (ADCA.CH0.INTFLAGS==0){};		// wait for measurement to complete
  93:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH0.RESH))<<8)|((int16_t)ADCA.CH0.RESL))>>4;	
  94:../src/rgb_sensor.c **** 		ADCA.CH0.INTFLAGS=1; // clear the complete flag				
  95:../src/rgb_sensor.c **** 		//printf("%6d ", meas[meas_count]);
  96:../src/rgb_sensor.c **** 	}
  97:../src/rgb_sensor.c **** 	//printf("\r\n");
  98:../src/rgb_sensor.c **** 	red_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
  99:../src/rgb_sensor.c **** 	return red_val;
 100:../src/rgb_sensor.c **** }
 101:../src/rgb_sensor.c **** 
 102:../src/rgb_sensor.c **** int16_t get_green_sensor(){
 103:../src/rgb_sensor.c **** 	int16_t meas[RGB_MEAS_COUNT];
 104:../src/rgb_sensor.c **** 	int16_t green_val;		
 105:../src/rgb_sensor.c **** 	//printf("G: ");
 106:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++)	{
 107:../src/rgb_sensor.c **** 		ADCA.CH1.CTRL |= ADC_CH_START_bm;
 108:../src/rgb_sensor.c **** 		while (ADCA.CH1.INTFLAGS==0){};		// wait for measurement to complete
 109:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH1.RESH))<<8)|((int16_t)ADCA.CH1.RESL))>>4;		
 110:../src/rgb_sensor.c **** 		ADCA.CH1.INTFLAGS=1; // clear the complete flag	
 111:../src/rgb_sensor.c **** 		//printf("%6d ", meas[meas_count]);
 112:../src/rgb_sensor.c **** 	}
 113:../src/rgb_sensor.c **** 	//printf("\r\n");
 114:../src/rgb_sensor.c **** 	green_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
 115:../src/rgb_sensor.c **** 
 116:../src/rgb_sensor.c **** 	return green_val;
 117:../src/rgb_sensor.c **** }
 118:../src/rgb_sensor.c **** 
 119:../src/rgb_sensor.c **** int16_t get_blue_sensor(){
 120:../src/rgb_sensor.c **** 	int16_t meas[RGB_MEAS_COUNT];
 121:../src/rgb_sensor.c **** 	int16_t blue_val;
 122:../src/rgb_sensor.c **** 	//printf("B: ");
 123:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++)	{
 124:../src/rgb_sensor.c **** 		ADCA.CH2.CTRL |= ADC_CH_START_bm;
 125:../src/rgb_sensor.c **** 		while (ADCA.CH2.INTFLAGS==0){};		// wait for measurement to complete
 126:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH2.RESH))<<8)|((int16_t)ADCA.CH2.RESL))>>4;
 127:../src/rgb_sensor.c **** 		ADCA.CH2.INTFLAGS=1; // clear the complete flag		
 128:../src/rgb_sensor.c **** 		//printf("%6d ", meas[meas_count]);
 129:../src/rgb_sensor.c **** 	}		
 130:../src/rgb_sensor.c **** 	//printf("\r\n");
 131:../src/rgb_sensor.c **** 	blue_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
 132:../src/rgb_sensor.c **** 		
 133:../src/rgb_sensor.c **** 	return blue_val;
 134:../src/rgb_sensor.c **** }
 135:../src/rgb_sensor.c **** 
 136:../src/rgb_sensor.c **** #endif
 137:../src/rgb_sensor.c **** 
 138:../src/rgb_sensor.c **** 
 139:../src/rgb_sensor.c **** void get_rgb(int16_t *r, int16_t *g, int16_t *b)
 140:../src/rgb_sensor.c **** {
 141:../src/rgb_sensor.c **** 	#ifdef AUDIO_DROPLET
 142:../src/rgb_sensor.c **** 		uint8_t write_sequence = 0xB4;
 143:../src/rgb_sensor.c **** 		uint8_t result = TWI_MasterWriteRead(RGB_SENSE_ADDR, &write_sequence, 1, 8);
 144:../src/rgb_sensor.c **** 		uint16_t* temp_values = (uint16_t*)(twi->readData);
 145:../src/rgb_sensor.c **** 		if(result)
 146:../src/rgb_sensor.c **** 		{
 147:../src/rgb_sensor.c **** 			//*c=temp_values[0];
 148:../src/rgb_sensor.c **** 			*r=(int16_t)temp_values[1];
 149:../src/rgb_sensor.c **** 			*g=(int16_t)temp_values[2];
 150:../src/rgb_sensor.c **** 			*b=(int16_t)temp_values[3];
 151:../src/rgb_sensor.c **** 		}
 152:../src/rgb_sensor.c **** 		else printf_P(PSTR("Read failed.\r\n"));
 153:../src/rgb_sensor.c **** 	#else
 154:../src/rgb_sensor.c **** 		int16_t rTemp,gTemp,bTemp;
 155:../src/rgb_sensor.c **** 	
 156:../src/rgb_sensor.c **** 		rTemp = get_red_sensor();
 157:../src/rgb_sensor.c **** 		gTemp = get_green_sensor();
 158:../src/rgb_sensor.c **** 		bTemp = get_blue_sensor();		
 159:../src/rgb_sensor.c **** 		rTemp = rTemp - r_baseline;
 160:../src/rgb_sensor.c **** 		gTemp = gTemp - g_baseline;
 161:../src/rgb_sensor.c **** 		bTemp = bTemp - b_baseline;
 162:../src/rgb_sensor.c **** 		//if(rTemp<0)	rTemp=0;
 163:../src/rgb_sensor.c **** 		//if(gTemp<0)	gTemp=0;
 164:../src/rgb_sensor.c **** 		//if(bTemp<0)	bTemp=0;
 165:../src/rgb_sensor.c **** 		if(r!=NULL) *r = rTemp;
 166:../src/rgb_sensor.c **** 		if(g!=NULL) *g = gTemp;
 167:../src/rgb_sensor.c **** 		if(b!=NULL) *b = bTemp;
 168:../src/rgb_sensor.c **** 	#endif
 169:../src/rgb_sensor.c **** }
 170:../src/rgb_sensor.c **** 
 171:../src/rgb_sensor.c **** // Finds the median of arr_len numbers by finding the max, finding the min, and returning the other
 172:../src/rgb_sensor.c **** // WARNING! This function modifies the array!
 173:../src/rgb_sensor.c **** int16_t meas_find_median(int16_t* meas, uint8_t arr_len){
  18               		.loc 1 173 0
  19               		.cfi_startproc
  20               	.LVL0:
  21 0000 CF93      		push r28
  22               	.LCFI0:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 28, -3
  25 0002 DF93      		push r29
  26               	.LCFI1:
  27               		.cfi_def_cfa_offset 5
  28               		.cfi_offset 29, -4
  29               	/* prologue: function */
  30               	/* frame size = 0 */
  31               	/* stack size = 2 */
  32               	.L__stack_usage = 2
  33 0004 EC01      		movw r28,r24
 174:../src/rgb_sensor.c **** 	if(arr_len==1) return meas[0];
  34               		.loc 1 174 0
  35 0006 6130      		cpi r22,lo8(1)
  36 0008 01F4      		brne .+2
  37 000a 00C0      		rjmp .L19
 175:../src/rgb_sensor.c **** 	else if(arr_len==2) return (meas[0]+meas[1])/2;
  38               		.loc 1 175 0
  39 000c 6230      		cpi r22,lo8(2)
  40 000e 01F4      		brne .+2
  41 0010 00C0      		rjmp .L20
  42               	.LVL1:
  43               	.LBB20:
 176:../src/rgb_sensor.c **** 	
 177:../src/rgb_sensor.c **** 	for(uint8_t i=0; i<arr_len ; i++){
  44               		.loc 1 177 0 discriminator 1
  45 0012 6623      		tst r22
  46 0014 01F0      		breq .L12
  47 0016 DE01      		movw r26,r28
  48               		.loc 1 177 0 is_stmt 0
  49 0018 80E0      		ldi r24,0
  50               	.LVL2:
  51               	.LBB21:
 178:../src/rgb_sensor.c **** 		for(uint8_t j=i+1 ; j<arr_len ; j++){
  52               		.loc 1 178 0 is_stmt 1
  53 001a 8F5F      		subi r24,lo8(-(1))
  54               	.LVL3:
  55 001c 6817      		cp r22,r24
  56 001e 01F0      		breq .L6
  57               	.LVL4:
  58               	.L21:
  59 0020 982F      		mov r25,r24
  60               	.LVL5:
  61               	.L8:
 179:../src/rgb_sensor.c **** 			if(meas[j] < meas[i]){
  62               		.loc 1 179 0
  63 0022 E92F      		mov r30,r25
  64 0024 F0E0      		ldi r31,0
  65 0026 EE0F      		lsl r30
  66 0028 FF1F      		rol r31
  67 002a EC0F      		add r30,r28
  68 002c FD1F      		adc r31,r29
  69 002e 4081      		ld r20,Z
  70 0030 5181      		ldd r21,Z+1
  71 0032 2D91      		ld r18,X+
  72 0034 3C91      		ld r19,X
  73 0036 1197      		sbiw r26,1
  74 0038 4217      		cp r20,r18
  75 003a 5307      		cpc r21,r19
  76 003c 04F4      		brge .L7
  77               	.LVL6:
  78               	.LBB22:
 180:../src/rgb_sensor.c **** 				int16_t temp = meas[i];
 181:../src/rgb_sensor.c **** 				meas[i] = meas[j];
  79               		.loc 1 181 0
  80 003e 4D93      		st X+,r20
  81 0040 5C93      		st X,r21
  82 0042 1197      		sbiw r26,1
 182:../src/rgb_sensor.c **** 				meas[j] = temp;
  83               		.loc 1 182 0
  84 0044 2083      		st Z,r18
  85 0046 3183      		std Z+1,r19
  86               	.LVL7:
  87               	.L7:
  88               	.LBE22:
 178:../src/rgb_sensor.c **** 			if(meas[j] < meas[i]){
  89               		.loc 1 178 0 discriminator 2
  90 0048 9F5F      		subi r25,lo8(-(1))
  91               	.LVL8:
  92 004a 6913      		cpse r22,r25
  93 004c 00C0      		rjmp .L8
  94 004e 1296      		adiw r26,2
  95               	.LVL9:
 178:../src/rgb_sensor.c **** 			if(meas[j] < meas[i]){
  96               		.loc 1 178 0 is_stmt 0
  97 0050 8F5F      		subi r24,lo8(-(1))
  98               	.LVL10:
  99 0052 6813      		cpse r22,r24
 100 0054 00C0      		rjmp .L21
 101               	.LVL11:
 102               	.L6:
 103               	.LBE21:
 104               	.LBE20:
 183:../src/rgb_sensor.c **** 			}
 184:../src/rgb_sensor.c **** 		}
 185:../src/rgb_sensor.c **** 	}
 186:../src/rgb_sensor.c **** 	if(arr_len%2==0) return (meas[arr_len/2-1]+meas[arr_len/2])/2;
 105               		.loc 1 186 0 is_stmt 1
 106 0056 60FF      		sbrs r22,0
 107 0058 00C0      		rjmp .L12
 187:../src/rgb_sensor.c **** 	else return meas[arr_len/2];
 108               		.loc 1 187 0
 109 005a 6695      		lsr r22
 110               	.LVL12:
 111 005c 262F      		mov r18,r22
 112 005e 30E0      		ldi r19,0
 113 0060 220F      		lsl r18
 114 0062 331F      		rol r19
 115               	.LVL13:
 116 0064 FE01      		movw r30,r28
 117 0066 E20F      		add r30,r18
 118 0068 F31F      		adc r31,r19
 119 006a 8081      		ld r24,Z
 120 006c 9181      		ldd r25,Z+1
 121               	/* epilogue start */
 188:../src/rgb_sensor.c **** }...
 122               		.loc 1 188 0
 123 006e DF91      		pop r29
 124 0070 CF91      		pop r28
 125               	.LVL14:
 126 0072 0895      		ret
 127               	.LVL15:
 128               	.L12:
 129               	.LBB23:
 130               	.LBB24:
 186:../src/rgb_sensor.c **** 	if(arr_len%2==0) return (meas[arr_len/2-1]+meas[arr_len/2])/2;
 131               		.loc 1 186 0
 132 0074 6695      		lsr r22
 133               	.LVL16:
 134 0076 FE01      		movw r30,r28
 135 0078 E60F      		add r30,r22
 136 007a F11D      		adc r31,__zero_reg__
 137 007c E60F      		add r30,r22
 138 007e F11D      		adc r31,__zero_reg__
 139 0080 3297      		sbiw r30,2
 140 0082 2281      		ldd r18,Z+2
 141 0084 3381      		ldd r19,Z+3
 142 0086 8081      		ld r24,Z
 143 0088 9181      		ldd r25,Z+1
 144 008a 820F      		add r24,r18
 145 008c 931F      		adc r25,r19
 146 008e 97FD      		sbrc r25,7
 147 0090 00C0      		rjmp .L17
 148               	.LVL17:
 149               	.L11:
 150 0092 9595      		asr r25
 151 0094 8795      		ror r24
 152               	/* epilogue start */
 153               	.LBE24:
 154               	.LBE23:
 155               		.loc 1 188 0
 156 0096 DF91      		pop r29
 157 0098 CF91      		pop r28
 158               	.LVL18:
 159 009a 0895      		ret
 160               	.LVL19:
 161               	.L19:
 174:../src/rgb_sensor.c **** 	if(arr_len==1) return meas[0];
 162               		.loc 1 174 0 discriminator 1
 163 009c 8881      		ld r24,Y
 164 009e 9981      		ldd r25,Y+1
 165               	.LVL20:
 166               	/* epilogue start */
 167               		.loc 1 188 0 discriminator 1
 168 00a0 DF91      		pop r29
 169 00a2 CF91      		pop r28
 170               	.LVL21:
 171 00a4 0895      		ret
 172               	.LVL22:
 173               	.L20:
 175:../src/rgb_sensor.c **** 	else if(arr_len==2) return (meas[0]+meas[1])/2;
 174               		.loc 1 175 0 discriminator 1
 175 00a6 2881      		ld r18,Y
 176 00a8 3981      		ldd r19,Y+1
 177 00aa 8A81      		ldd r24,Y+2
 178 00ac 9B81      		ldd r25,Y+3
 179               	.LVL23:
 180 00ae 820F      		add r24,r18
 181 00b0 931F      		adc r25,r19
 182 00b2 97FF      		sbrs r25,7
 183 00b4 00C0      		rjmp .L11
 184               	.LVL24:
 185               	.L17:
 186               	.LBB26:
 187               	.LBB25:
 186:../src/rgb_sensor.c **** 	if(arr_len%2==0) return (meas[arr_len/2-1]+meas[arr_len/2])/2;
 188               		.loc 1 186 0
 189 00b6 0196      		adiw r24,1
 190 00b8 00C0      		rjmp .L11
 191               	.LBE25:
 192               	.LBE26:
 193               		.cfi_endproc
 194               	.LFE41:
 196               		.section	.text.get_red_sensor,"ax",@progbits
 197               	.global	get_red_sensor
 199               	get_red_sensor:
 200               	.LFB37:
  86:../src/rgb_sensor.c **** int16_t get_red_sensor(){
 201               		.loc 1 86 0
 202               		.cfi_startproc
 203 0000 CF93      		push r28
 204               	.LCFI2:
 205               		.cfi_def_cfa_offset 4
 206               		.cfi_offset 28, -3
 207 0002 DF93      		push r29
 208               	.LCFI3:
 209               		.cfi_def_cfa_offset 5
 210               		.cfi_offset 29, -4
 211 0004 CDB7      		in r28,__SP_L__
 212 0006 DEB7      		in r29,__SP_H__
 213               	.LCFI4:
 214               		.cfi_def_cfa_register 28
 215 0008 2A97      		sbiw r28,10
 216               	.LCFI5:
 217               		.cfi_def_cfa_offset 15
 218 000a CDBF      		out __SP_L__,r28
 219 000c DEBF      		out __SP_H__,r29
 220               	/* prologue: function */
 221               	/* frame size = 10 */
 222               	/* stack size = 12 */
 223               	.L__stack_usage = 12
 224               	.LVL25:
 225 000e FE01      		movw r30,r28
 226 0010 3196      		adiw r30,1
 227 0012 AE01      		movw r20,r28
 228 0014 455F      		subi r20,-11
 229 0016 5F4F      		sbci r21,-1
 230               	.LBB27:
  94:../src/rgb_sensor.c **** 		ADCA.CH0.INTFLAGS=1; // clear the complete flag				
 231               		.loc 1 94 0
 232 0018 31E0      		ldi r19,lo8(1)
 233               	.LVL26:
 234               	.L24:
  91:../src/rgb_sensor.c **** 		ADCA.CH0.CTRL |= ADC_CH_START_bm;
 235               		.loc 1 91 0
 236 001a 8091 2002 		lds r24,544
 237 001e 8068      		ori r24,lo8(-128)
 238 0020 8093 2002 		sts 544,r24
 239               	.L23:
  92:../src/rgb_sensor.c **** 		while (ADCA.CH0.INTFLAGS==0){};		// wait for measurement to complete
 240               		.loc 1 92 0 discriminator 1
 241 0024 8091 2302 		lds r24,547
 242 0028 8823      		tst r24
 243 002a 01F0      		breq .L23
  93:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH0.RESH))<<8)|((int16_t)ADCA.CH0.RESL))>>4;	
 244               		.loc 1 93 0 discriminator 2
 245 002c 2091 2502 		lds r18,549
 246 0030 8091 2402 		lds r24,548
 247 0034 90E0      		ldi r25,0
 248 0036 922B      		or r25,r18
 249 0038 9595      		asr r25
 250 003a 8795      		ror r24
 251 003c 9595      		asr r25
 252 003e 8795      		ror r24
 253 0040 9595      		asr r25
 254 0042 8795      		ror r24
 255 0044 9595      		asr r25
 256 0046 8795      		ror r24
 257 0048 8193      		st Z+,r24
 258 004a 9193      		st Z+,r25
  94:../src/rgb_sensor.c **** 		ADCA.CH0.INTFLAGS=1; // clear the complete flag				
 259               		.loc 1 94 0 discriminator 2
 260 004c 3093 2302 		sts 547,r19
  90:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++){
 261               		.loc 1 90 0 discriminator 2
 262 0050 E417      		cp r30,r20
 263 0052 F507      		cpc r31,r21
 264 0054 01F4      		brne .L24
 265               	.LBE27:
  98:../src/rgb_sensor.c **** 	red_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
 266               		.loc 1 98 0
 267 0056 63E0      		ldi r22,lo8(3)
 268 0058 CE01      		movw r24,r28
 269 005a 0596      		adiw r24,5
 270 005c 0E94 0000 		call meas_find_median
 271               	.LVL27:
 272               	/* epilogue start */
 100:../src/rgb_sensor.c **** }
 273               		.loc 1 100 0
 274 0060 2A96      		adiw r28,10
 275 0062 CDBF      		out __SP_L__,r28
 276 0064 DEBF      		out __SP_H__,r29
 277 0066 DF91      		pop r29
 278 0068 CF91      		pop r28
 279 006a 0895      		ret
 280               		.cfi_endproc
 281               	.LFE37:
 283               		.section	.text.get_green_sensor,"ax",@progbits
 284               	.global	get_green_sensor
 286               	get_green_sensor:
 287               	.LFB38:
 102:../src/rgb_sensor.c **** int16_t get_green_sensor(){
 288               		.loc 1 102 0
 289               		.cfi_startproc
 290 0000 CF93      		push r28
 291               	.LCFI6:
 292               		.cfi_def_cfa_offset 4
 293               		.cfi_offset 28, -3
 294 0002 DF93      		push r29
 295               	.LCFI7:
 296               		.cfi_def_cfa_offset 5
 297               		.cfi_offset 29, -4
 298 0004 CDB7      		in r28,__SP_L__
 299 0006 DEB7      		in r29,__SP_H__
 300               	.LCFI8:
 301               		.cfi_def_cfa_register 28
 302 0008 2A97      		sbiw r28,10
 303               	.LCFI9:
 304               		.cfi_def_cfa_offset 15
 305 000a CDBF      		out __SP_L__,r28
 306 000c DEBF      		out __SP_H__,r29
 307               	/* prologue: function */
 308               	/* frame size = 10 */
 309               	/* stack size = 12 */
 310               	.L__stack_usage = 12
 311               	.LVL28:
 312 000e FE01      		movw r30,r28
 313 0010 3196      		adiw r30,1
 314 0012 AE01      		movw r20,r28
 315 0014 455F      		subi r20,-11
 316 0016 5F4F      		sbci r21,-1
 317               	.LBB28:
 110:../src/rgb_sensor.c **** 		ADCA.CH1.INTFLAGS=1; // clear the complete flag	
 318               		.loc 1 110 0
 319 0018 31E0      		ldi r19,lo8(1)
 320               	.LVL29:
 321               	.L30:
 107:../src/rgb_sensor.c **** 		ADCA.CH1.CTRL |= ADC_CH_START_bm;
 322               		.loc 1 107 0
 323 001a 8091 2802 		lds r24,552
 324 001e 8068      		ori r24,lo8(-128)
 325 0020 8093 2802 		sts 552,r24
 326               	.L29:
 108:../src/rgb_sensor.c **** 		while (ADCA.CH1.INTFLAGS==0){};		// wait for measurement to complete
 327               		.loc 1 108 0 discriminator 1
 328 0024 8091 2B02 		lds r24,555
 329 0028 8823      		tst r24
 330 002a 01F0      		breq .L29
 109:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH1.RESH))<<8)|((int16_t)ADCA.CH1.RESL))>>4;		
 331               		.loc 1 109 0 discriminator 2
 332 002c 2091 2D02 		lds r18,557
 333 0030 8091 2C02 		lds r24,556
 334 0034 90E0      		ldi r25,0
 335 0036 922B      		or r25,r18
 336 0038 9595      		asr r25
 337 003a 8795      		ror r24
 338 003c 9595      		asr r25
 339 003e 8795      		ror r24
 340 0040 9595      		asr r25
 341 0042 8795      		ror r24
 342 0044 9595      		asr r25
 343 0046 8795      		ror r24
 344 0048 8193      		st Z+,r24
 345 004a 9193      		st Z+,r25
 110:../src/rgb_sensor.c **** 		ADCA.CH1.INTFLAGS=1; // clear the complete flag	
 346               		.loc 1 110 0 discriminator 2
 347 004c 3093 2B02 		sts 555,r19
 106:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++)	{
 348               		.loc 1 106 0 discriminator 2
 349 0050 E417      		cp r30,r20
 350 0052 F507      		cpc r31,r21
 351 0054 01F4      		brne .L30
 352               	.LBE28:
 114:../src/rgb_sensor.c **** 	green_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
 353               		.loc 1 114 0
 354 0056 63E0      		ldi r22,lo8(3)
 355 0058 CE01      		movw r24,r28
 356 005a 0596      		adiw r24,5
 357 005c 0E94 0000 		call meas_find_median
 358               	.LVL30:
 359               	/* epilogue start */
 117:../src/rgb_sensor.c **** }
 360               		.loc 1 117 0
 361 0060 2A96      		adiw r28,10
 362 0062 CDBF      		out __SP_L__,r28
 363 0064 DEBF      		out __SP_H__,r29
 364 0066 DF91      		pop r29
 365 0068 CF91      		pop r28
 366 006a 0895      		ret
 367               		.cfi_endproc
 368               	.LFE38:
 370               		.section	.text.get_blue_sensor,"ax",@progbits
 371               	.global	get_blue_sensor
 373               	get_blue_sensor:
 374               	.LFB39:
 119:../src/rgb_sensor.c **** int16_t get_blue_sensor(){
 375               		.loc 1 119 0
 376               		.cfi_startproc
 377 0000 CF93      		push r28
 378               	.LCFI10:
 379               		.cfi_def_cfa_offset 4
 380               		.cfi_offset 28, -3
 381 0002 DF93      		push r29
 382               	.LCFI11:
 383               		.cfi_def_cfa_offset 5
 384               		.cfi_offset 29, -4
 385 0004 CDB7      		in r28,__SP_L__
 386 0006 DEB7      		in r29,__SP_H__
 387               	.LCFI12:
 388               		.cfi_def_cfa_register 28
 389 0008 2A97      		sbiw r28,10
 390               	.LCFI13:
 391               		.cfi_def_cfa_offset 15
 392 000a CDBF      		out __SP_L__,r28
 393 000c DEBF      		out __SP_H__,r29
 394               	/* prologue: function */
 395               	/* frame size = 10 */
 396               	/* stack size = 12 */
 397               	.L__stack_usage = 12
 398               	.LVL31:
 399 000e FE01      		movw r30,r28
 400 0010 3196      		adiw r30,1
 401 0012 AE01      		movw r20,r28
 402 0014 455F      		subi r20,-11
 403 0016 5F4F      		sbci r21,-1
 404               	.LBB29:
 127:../src/rgb_sensor.c **** 		ADCA.CH2.INTFLAGS=1; // clear the complete flag		
 405               		.loc 1 127 0
 406 0018 31E0      		ldi r19,lo8(1)
 407               	.LVL32:
 408               	.L36:
 124:../src/rgb_sensor.c **** 		ADCA.CH2.CTRL |= ADC_CH_START_bm;
 409               		.loc 1 124 0
 410 001a 8091 3002 		lds r24,560
 411 001e 8068      		ori r24,lo8(-128)
 412 0020 8093 3002 		sts 560,r24
 413               	.L35:
 125:../src/rgb_sensor.c **** 		while (ADCA.CH2.INTFLAGS==0){};		// wait for measurement to complete
 414               		.loc 1 125 0 discriminator 1
 415 0024 8091 3302 		lds r24,563
 416 0028 8823      		tst r24
 417 002a 01F0      		breq .L35
 126:../src/rgb_sensor.c **** 		meas[meas_count] = ((((int16_t)(ADCA.CH2.RESH))<<8)|((int16_t)ADCA.CH2.RESL))>>4;
 418               		.loc 1 126 0 discriminator 2
 419 002c 2091 3502 		lds r18,565
 420 0030 8091 3402 		lds r24,564
 421 0034 90E0      		ldi r25,0
 422 0036 922B      		or r25,r18
 423 0038 9595      		asr r25
 424 003a 8795      		ror r24
 425 003c 9595      		asr r25
 426 003e 8795      		ror r24
 427 0040 9595      		asr r25
 428 0042 8795      		ror r24
 429 0044 9595      		asr r25
 430 0046 8795      		ror r24
 431 0048 8193      		st Z+,r24
 432 004a 9193      		st Z+,r25
 127:../src/rgb_sensor.c **** 		ADCA.CH2.INTFLAGS=1; // clear the complete flag		
 433               		.loc 1 127 0 discriminator 2
 434 004c 3093 3302 		sts 563,r19
 123:../src/rgb_sensor.c **** 	for(uint8_t meas_count=0; meas_count<RGB_MEAS_COUNT; meas_count++)	{
 435               		.loc 1 123 0 discriminator 2
 436 0050 E417      		cp r30,r20
 437 0052 F507      		cpc r31,r21
 438 0054 01F4      		brne .L36
 439               	.LBE29:
 131:../src/rgb_sensor.c **** 	blue_val=meas_find_median(&meas[2], RGB_MEAS_COUNT-2);
 440               		.loc 1 131 0
 441 0056 63E0      		ldi r22,lo8(3)
 442 0058 CE01      		movw r24,r28
 443 005a 0596      		adiw r24,5
 444 005c 0E94 0000 		call meas_find_median
 445               	.LVL33:
 446               	/* epilogue start */
 134:../src/rgb_sensor.c **** }
 447               		.loc 1 134 0
 448 0060 2A96      		adiw r28,10
 449 0062 CDBF      		out __SP_L__,r28
 450 0064 DEBF      		out __SP_H__,r29
 451 0066 DF91      		pop r29
 452 0068 CF91      		pop r28
 453 006a 0895      		ret
 454               		.cfi_endproc
 455               	.LFE39:
 457               		.section	.text.rgb_sensor_init,"ax",@progbits
 458               	.global	rgb_sensor_init
 460               	rgb_sensor_init:
 461               	.LFB36:
  19:../src/rgb_sensor.c **** {
 462               		.loc 1 19 0
 463               		.cfi_startproc
 464 0000 CF93      		push r28
 465               	.LCFI14:
 466               		.cfi_def_cfa_offset 4
 467               		.cfi_offset 28, -3
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 1 */
 471               	.L__stack_usage = 1
  39:../src/rgb_sensor.c **** 		RGB_SENSOR_PORT.DIRCLR = RGB_SENSOR_R_PIN_bm | RGB_SENSOR_G_PIN_bm | RGB_SENSOR_B_PIN_bm;
 472               		.loc 1 39 0
 473 0002 80EE      		ldi r24,lo8(-32)
 474 0004 8093 0206 		sts 1538,r24
  41:../src/rgb_sensor.c **** 		ADCA.REFCTRL = ADC_REFSEL_AREFA_gc;
 475               		.loc 1 41 0
 476 0008 80E2      		ldi r24,lo8(32)
 477 000a 8093 0202 		sts 514,r24
  42:../src/rgb_sensor.c **** 		ADCA.CTRLB = ADC_RESOLUTION_LEFT12BIT_gc | ADC_CONMODE_bm;
 478               		.loc 1 42 0
 479 000e 86E1      		ldi r24,lo8(22)
 480 0010 8093 0102 		sts 513,r24
  43:../src/rgb_sensor.c **** 		ADCA.PRESCALER = ADC_PRESCALER_DIV256_gc;
 481               		.loc 1 43 0
 482 0014 86E0      		ldi r24,lo8(6)
 483 0016 8093 0402 		sts 516,r24
  46:../src/rgb_sensor.c **** 		ADCA.CH0.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_1X_gc;	//Probably should turn the gai
 484               		.loc 1 46 0
 485 001a 83E0      		ldi r24,lo8(3)
 486 001c 8093 2002 		sts 544,r24
  47:../src/rgb_sensor.c **** 		ADCA.CH1.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_1X_gc;	//Probably should turn the gai
 487               		.loc 1 47 0
 488 0020 8093 2802 		sts 552,r24
  48:../src/rgb_sensor.c **** 		ADCA.CH2.CTRL = ADC_CH_INPUTMODE_DIFFWGAIN_gc | ADC_CH_GAIN_2X_gc;	//Probably should turn the gai
 489               		.loc 1 48 0
 490 0024 87E0      		ldi r24,lo8(7)
 491 0026 8093 3002 		sts 560,r24
  50:../src/rgb_sensor.c **** 		ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN5_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Red sensor on ADC A 
 492               		.loc 1 50 0
 493 002a 8CE2      		ldi r24,lo8(44)
 494 002c 8093 2102 		sts 545,r24
  51:../src/rgb_sensor.c **** 		ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN6_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Green sensor on ADC 
 495               		.loc 1 51 0
 496 0030 84E3      		ldi r24,lo8(52)
 497 0032 8093 2902 		sts 553,r24
  52:../src/rgb_sensor.c **** 		ADCA.CH2.MUXCTRL = ADC_CH_MUXPOS_PIN7_gc | ADC_CH_MUXNEG_INTGND_MODE4_gc;	// Blue sensor on ADC A
 498               		.loc 1 52 0
 499 0036 8CE3      		ldi r24,lo8(60)
 500 0038 8093 3102 		sts 561,r24
  54:../src/rgb_sensor.c **** 		ADCA.CALL = PRODSIGNATURES_ADCACAL0;
 501               		.loc 1 54 0
 502 003c 80B5      		in r24,0x20
 503 003e 8093 0C02 		sts 524,r24
  55:../src/rgb_sensor.c **** 		ADCA.CALH = PRODSIGNATURES_ADCACAL1;
 504               		.loc 1 55 0
 505 0042 81B5      		in r24,0x21
 506 0044 8093 0D02 		sts 525,r24
  57:../src/rgb_sensor.c **** 		ADCA.CTRLA = ADC_ENABLE_bm;
 507               		.loc 1 57 0
 508 0048 81E0      		ldi r24,lo8(1)
 509 004a 8093 0002 		sts 512,r24
 510               	.LVL34:
 511               	.LBB30:
 512               	.LBB31:
 513               	.LBB32:
 514               		.file 2 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
   1:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:c:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 515               		.loc 2 276 0
 516 004e 8FE8      		ldi r24,lo8(399)
 517 0050 91E0      		ldi r25,hi8(399)
 518 0052 0197      	1:	sbiw r24,1
 519 0054 01F4      		brne 1b
 520 0056 00C0      		rjmp .
 521 0058 0000      		nop
 522               	.LVL35:
 523               	.LBE32:
 524               	.LBE31:
 525               	.LBE30:
  63:../src/rgb_sensor.c **** 		get_red_sensor(); get_blue_sensor(); get_green_sensor();
 526               		.loc 1 63 0
 527 005a 0E94 0000 		call get_red_sensor
 528               	.LVL36:
 529 005e 0E94 0000 		call get_blue_sensor
 530               	.LVL37:
 531 0062 0E94 0000 		call get_green_sensor
 532               	.LVL38:
  64:../src/rgb_sensor.c **** 		delay_ms(10);
 533               		.loc 1 64 0
 534 0066 8AE0      		ldi r24,lo8(10)
 535 0068 90E0      		ldi r25,0
 536 006a 0E94 0000 		call delay_ms
 537               	.LVL39:
 538 006e C0E0      		ldi r28,0
 539               	.LVL40:
 540               	.L41:
 541               	.LBB33:
  68:../src/rgb_sensor.c **** 			r_avg+=get_red_sensor();
 542               		.loc 1 68 0 discriminator 3
 543 0070 0E94 0000 		call get_red_sensor
 544               	.LVL41:
  69:../src/rgb_sensor.c **** 			g_avg+=get_green_sensor();
 545               		.loc 1 69 0 discriminator 3
 546 0074 0E94 0000 		call get_green_sensor
 547               	.LVL42:
  70:../src/rgb_sensor.c **** 			b_avg+=get_blue_sensor();
 548               		.loc 1 70 0 discriminator 3
 549 0078 0E94 0000 		call get_blue_sensor
 550               	.LVL43:
  71:../src/rgb_sensor.c **** 			delay_ms(10);
 551               		.loc 1 71 0 discriminator 3
 552 007c 8AE0      		ldi r24,lo8(10)
 553 007e 90E0      		ldi r25,0
 554 0080 0E94 0000 		call delay_ms
 555               	.LVL44:
  66:../src/rgb_sensor.c **** 		for(uint8_t i=0; i<num_samples; i++)
 556               		.loc 1 66 0 discriminator 3
 557 0084 CF5F      		subi r28,lo8(-(1))
 558               	.LVL45:
 559 0086 C330      		cpi r28,lo8(3)
 560 0088 01F4      		brne .L41
 561               	.LBE33:
  78:../src/rgb_sensor.c **** 		r_baseline = 0;
 562               		.loc 1 78 0
 563 008a 1092 0000 		sts r_baseline,__zero_reg__
 564 008e 1092 0000 		sts r_baseline+1,__zero_reg__
  79:../src/rgb_sensor.c **** 		g_baseline = 0;
 565               		.loc 1 79 0
 566 0092 1092 0000 		sts g_baseline,__zero_reg__
 567 0096 1092 0000 		sts g_baseline+1,__zero_reg__
  80:../src/rgb_sensor.c **** 		b_baseline = 0;	
 568               		.loc 1 80 0
 569 009a 1092 0000 		sts b_baseline,__zero_reg__
 570 009e 1092 0000 		sts b_baseline+1,__zero_reg__
 571               	/* epilogue start */
  82:../src/rgb_sensor.c **** }
 572               		.loc 1 82 0
 573 00a2 CF91      		pop r28
 574               	.LVL46:
 575 00a4 0895      		ret
 576               		.cfi_endproc
 577               	.LFE36:
 579               		.section	.text.get_rgb,"ax",@progbits
 580               	.global	get_rgb
 582               	get_rgb:
 583               	.LFB40:
 140:../src/rgb_sensor.c **** {
 584               		.loc 1 140 0
 585               		.cfi_startproc
 586               	.LVL47:
 587 0000 AF92      		push r10
 588               	.LCFI15:
 589               		.cfi_def_cfa_offset 4
 590               		.cfi_offset 10, -3
 591 0002 BF92      		push r11
 592               	.LCFI16:
 593               		.cfi_def_cfa_offset 5
 594               		.cfi_offset 11, -4
 595 0004 CF92      		push r12
 596               	.LCFI17:
 597               		.cfi_def_cfa_offset 6
 598               		.cfi_offset 12, -5
 599 0006 DF92      		push r13
 600               	.LCFI18:
 601               		.cfi_def_cfa_offset 7
 602               		.cfi_offset 13, -6
 603 0008 EF92      		push r14
 604               	.LCFI19:
 605               		.cfi_def_cfa_offset 8
 606               		.cfi_offset 14, -7
 607 000a FF92      		push r15
 608               	.LCFI20:
 609               		.cfi_def_cfa_offset 9
 610               		.cfi_offset 15, -8
 611 000c 0F93      		push r16
 612               	.LCFI21:
 613               		.cfi_def_cfa_offset 10
 614               		.cfi_offset 16, -9
 615 000e 1F93      		push r17
 616               	.LCFI22:
 617               		.cfi_def_cfa_offset 11
 618               		.cfi_offset 17, -10
 619 0010 CF93      		push r28
 620               	.LCFI23:
 621               		.cfi_def_cfa_offset 12
 622               		.cfi_offset 28, -11
 623 0012 DF93      		push r29
 624               	.LCFI24:
 625               		.cfi_def_cfa_offset 13
 626               		.cfi_offset 29, -12
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 10 */
 630               	.L__stack_usage = 10
 631 0014 5C01      		movw r10,r24
 632 0016 6B01      		movw r12,r22
 633 0018 7A01      		movw r14,r20
 156:../src/rgb_sensor.c **** 		rTemp = get_red_sensor();
 634               		.loc 1 156 0
 635 001a 0E94 0000 		call get_red_sensor
 636               	.LVL48:
 637 001e 8C01      		movw r16,r24
 638               	.LVL49:
 157:../src/rgb_sensor.c **** 		gTemp = get_green_sensor();
 639               		.loc 1 157 0
 640 0020 0E94 0000 		call get_green_sensor
 641               	.LVL50:
 642 0024 EC01      		movw r28,r24
 643               	.LVL51:
 158:../src/rgb_sensor.c **** 		bTemp = get_blue_sensor();		
 644               		.loc 1 158 0
 645 0026 0E94 0000 		call get_blue_sensor
 646               	.LVL52:
 159:../src/rgb_sensor.c **** 		rTemp = rTemp - r_baseline;
 647               		.loc 1 159 0
 648 002a 2091 0000 		lds r18,r_baseline
 649 002e 3091 0000 		lds r19,r_baseline+1
 650 0032 021B      		sub r16,r18
 651 0034 130B      		sbc r17,r19
 652               	.LVL53:
 160:../src/rgb_sensor.c **** 		gTemp = gTemp - g_baseline;
 653               		.loc 1 160 0
 654 0036 2091 0000 		lds r18,g_baseline
 655 003a 3091 0000 		lds r19,g_baseline+1
 656 003e C21B      		sub r28,r18
 657 0040 D30B      		sbc r29,r19
 658               	.LVL54:
 161:../src/rgb_sensor.c **** 		bTemp = bTemp - b_baseline;
 659               		.loc 1 161 0
 660 0042 2091 0000 		lds r18,b_baseline
 661 0046 3091 0000 		lds r19,b_baseline+1
 662 004a 821B      		sub r24,r18
 663 004c 930B      		sbc r25,r19
 664               	.LVL55:
 165:../src/rgb_sensor.c **** 		if(r!=NULL) *r = rTemp;
 665               		.loc 1 165 0
 666 004e A114      		cp r10,__zero_reg__
 667 0050 B104      		cpc r11,__zero_reg__
 668 0052 01F0      		breq .L44
 165:../src/rgb_sensor.c **** 		if(r!=NULL) *r = rTemp;
 669               		.loc 1 165 0 is_stmt 0 discriminator 1
 670 0054 F501      		movw r30,r10
 671 0056 0083      		st Z,r16
 672 0058 1183      		std Z+1,r17
 673               	.L44:
 166:../src/rgb_sensor.c **** 		if(g!=NULL) *g = gTemp;
 674               		.loc 1 166 0 is_stmt 1
 675 005a C114      		cp r12,__zero_reg__
 676 005c D104      		cpc r13,__zero_reg__
 677 005e 01F0      		breq .L45
 166:../src/rgb_sensor.c **** 		if(g!=NULL) *g = gTemp;
 678               		.loc 1 166 0 is_stmt 0 discriminator 1
 679 0060 F601      		movw r30,r12
 680 0062 C083      		st Z,r28
 681 0064 D183      		std Z+1,r29
 682               	.L45:
 167:../src/rgb_sensor.c **** 		if(b!=NULL) *b = bTemp;
 683               		.loc 1 167 0 is_stmt 1
 684 0066 E114      		cp r14,__zero_reg__
 685 0068 F104      		cpc r15,__zero_reg__
 686 006a 01F0      		breq .L43
 167:../src/rgb_sensor.c **** 		if(b!=NULL) *b = bTemp;
 687               		.loc 1 167 0 is_stmt 0 discriminator 1
 688 006c F701      		movw r30,r14
 689 006e 8083      		st Z,r24
 690 0070 9183      		std Z+1,r25
 691               	.L43:
 692               	/* epilogue start */
 169:../src/rgb_sensor.c **** }
 693               		.loc 1 169 0 is_stmt 1
 694 0072 DF91      		pop r29
 695 0074 CF91      		pop r28
 696               	.LVL56:
 697 0076 1F91      		pop r17
 698 0078 0F91      		pop r16
 699               	.LVL57:
 700 007a FF90      		pop r15
 701 007c EF90      		pop r14
 702               	.LVL58:
 703 007e DF90      		pop r13
 704 0080 CF90      		pop r12
 705               	.LVL59:
 706 0082 BF90      		pop r11
 707 0084 AF90      		pop r10
 708               	.LVL60:
 709 0086 0895      		ret
 710               		.cfi_endproc
 711               	.LFE40:
 713               		.section	.bss.b_baseline,"aw",@nobits
 716               	b_baseline:
 717 0000 0000      		.zero	2
 718               		.section	.bss.g_baseline,"aw",@nobits
 721               	g_baseline:
 722 0000 0000      		.zero	2
 723               		.section	.bss.r_baseline,"aw",@nobits
 726               	r_baseline:
 727 0000 0000      		.zero	2
 728               		.comm	twi,2,1
 729               		.comm	twiMaster,25,1
 730               		.section	.bss.task_storage_arr,"aw",@nobits
 733               	task_storage_arr:
 734 0000 0000 0000 		.zero	140
 734      0000 0000 
 734      0000 0000 
 734      0000 0000 
 734      0000 0000 
 735               		.comm	task_executing,1,1
 736               		.comm	num_tasks,1,1
 737               		.comm	task_list,2,1
 738               		.comm	rtc_epoch,2,1
 739               		.comm	droplet_ID,2,1
 740               		.text
 741               	.Letext0:
 742               		.file 3 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\in
 743               		.file 4 "C:/Program Files (x86)/Atmel/Studio/7.0/Packs/atmel/XMEGAA_DFP/1.1.68/include/avr/iox128a
 744               		.file 5 "../include/droplet_base.h"
 745               		.file 6 "../include/scheduler.h"
 746               		.file 7 "../include/i2c.h"
DEFINED SYMBOLS
                            *ABS*:00000000 rgb_sensor.c
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:2      *ABS*:0000003e __SP_H__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:3      *ABS*:0000003d __SP_L__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:4      *ABS*:0000003f __SREG__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:5      *ABS*:0000003b __RAMPZ__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:6      *ABS*:00000034 __CCP__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:7      *ABS*:00000000 __tmp_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:8      *ABS*:00000001 __zero_reg__
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:15     .text.meas_find_median:00000000 meas_find_median
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:199    .text.get_red_sensor:00000000 get_red_sensor
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:286    .text.get_green_sensor:00000000 get_green_sensor
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:373    .text.get_blue_sensor:00000000 get_blue_sensor
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:460    .text.rgb_sensor_init:00000000 rgb_sensor_init
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:726    .bss.r_baseline:00000000 r_baseline
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:721    .bss.g_baseline:00000000 g_baseline
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:716    .bss.b_baseline:00000000 b_baseline
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:582    .text.get_rgb:00000000 get_rgb
                            *COM*:00000002 twi
                            *COM*:00000019 twiMaster
C:\Users\JOHNK~1\AppData\Local\Temp\cc151Z9W.s:733    .bss.task_storage_arr:00000000 task_storage_arr
                            *COM*:00000001 task_executing
                            *COM*:00000001 num_tasks
                            *COM*:00000002 task_list
                            *COM*:00000002 rtc_epoch
                            *COM*:00000002 droplet_ID

UNDEFINED SYMBOLS
delay_ms
__do_clear_bss
