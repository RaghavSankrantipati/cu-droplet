\hypertarget{sp__driver_8h}{\section{sp\+\_\+driver.\+h File Reference}
\label{sp__driver_8h}\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
}


X\+M\+E\+G\+A Self-\/programming driver header file.  


{\ttfamily \#include $<$avr/io.\+h$>$}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \hyperlink{sp__driver_8h_a861f2edbb59b39aecaa4e2e419848041}{S\+P\+\_\+\+Read\+Byte} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Read a byte from flash. \end{DoxyCompactList}\item 
uint16\+\_\+t \hyperlink{sp__driver_8h_a4dcbd30344e9245c57ba8545a949c77e}{S\+P\+\_\+\+Read\+Word} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Read a word from flash. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{sp__driver_8h_abcc2ef603c461cd65a0fd08b2d97d78c}{S\+P\+\_\+\+Read\+Calibration\+Byte} (uint8\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Read calibration byte at given index. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{sp__driver_8h_a028b313c0219dff97ee0b8ee826ad578}{S\+P\+\_\+\+Read\+Fuse\+Byte} (uint8\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Read fuse byte from given index. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a70340a21824f27957af2ed59300b7a4a}{S\+P\+\_\+\+Write\+Lock\+Bits} (uint8\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Write lock bits. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{sp__driver_8h_a9b8eca47d5ffc611e4973bd6623b3c19}{S\+P\+\_\+\+Read\+Lock\+Bits} (void)
\begin{DoxyCompactList}\small\item\em Read lock bits. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{sp__driver_8h_ab79a6d78a9af76ffa62e2dccfcc5c1b4}{S\+P\+\_\+\+Read\+User\+Signature\+Byte} (uint16\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Read user signature at given index. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_ac99150fdc460f2149d61bccabece890f}{S\+P\+\_\+\+Erase\+User\+Signature\+Row} (void)
\begin{DoxyCompactList}\small\item\em Erase user signature row. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a660b4581eeefe19b3f0d80989abeaa39}{S\+P\+\_\+\+Write\+User\+Signature\+Row} (void)
\begin{DoxyCompactList}\small\item\em Write user signature row. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a8ebac0543ec938aa54e0ec412518ea35}{S\+P\+\_\+\+Erase\+Application\+Section} (void)
\begin{DoxyCompactList}\small\item\em Erase entire application section. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_aa236da5a509d82a611c4a4ce402f812d}{S\+P\+\_\+\+Erase\+Application\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Erase page at byte address in application or application table section. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a51aea1f2853f936d1f8b7c78f807599b}{S\+P\+\_\+\+Erase\+Write\+Application\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Erase and write page buffer to application or application table section at byte address. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a73fd220e37969fe8f9000c51aee3766b}{S\+P\+\_\+\+Write\+Application\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Write page buffer to application or application table section at byte address. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_ae6885c758d6ab15ff642d61c410d900b}{S\+P\+\_\+\+Load\+Flash\+Word} (uint16\+\_\+t address, uint16\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Load one word into Flash page buffer. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a6ee74fd6350479ede6fd43e8f6e907d5}{S\+P\+\_\+\+Load\+Flash\+Page} (const uint8\+\_\+t $\ast$data)
\begin{DoxyCompactList}\small\item\em Load entire page from S\+R\+A\+M buffer into Flash page buffer. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a289939190650886f1875c31e39fefdb1}{S\+P\+\_\+\+Read\+Flash\+Page} (const uint8\+\_\+t $\ast$data, uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Read entire Flash page into S\+R\+A\+M buffer. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_aa74a9476a4b9f347b9daf12c2f46141f}{S\+P\+\_\+\+Erase\+Flash\+Buffer} (void)
\begin{DoxyCompactList}\small\item\em Flush Flash page buffer. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a871749d5045b368d9d901e51dceb8ca8}{S\+P\+\_\+\+Erase\+Boot\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Erase page at byte address in boot section. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_adbb70c7a63522cbf39cfb3b9cd9afcbc}{S\+P\+\_\+\+Erase\+Write\+Boot\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Erase and write page buffer to boot section at byte address. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_afee128140615cf5639876e2efe7d8595}{S\+P\+\_\+\+Write\+Boot\+Page} (uint32\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Write page buffer to boot section at byte address. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{sp__driver_8h_a00e556f84f34b0406599d7d8fd5c1953}{S\+P\+\_\+\+Application\+C\+R\+C} (void)
\begin{DoxyCompactList}\small\item\em Generate C\+R\+C from application section. \end{DoxyCompactList}\item 
uint32\+\_\+t \hyperlink{sp__driver_8h_a426f0237e39b43bb8e59412496d14cbb}{S\+P\+\_\+\+Boot\+C\+R\+C} (void)
\begin{DoxyCompactList}\small\item\em Generate C\+R\+C from boot section. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_a999ae14f2a363cb4bcc06a4df180d0da}{S\+P\+\_\+\+Lock\+S\+P\+M} (void)
\begin{DoxyCompactList}\small\item\em Lock S\+P\+M instruction. \end{DoxyCompactList}\item 
void \hyperlink{sp__driver_8h_aa972c2c5f7d4393c945a851401c09718}{S\+P\+\_\+\+Wait\+For\+S\+P\+M} (void)
\begin{DoxyCompactList}\small\item\em Wait for S\+P\+M to finish. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
X\+M\+E\+G\+A Self-\/programming driver header file. 

This file contains the function prototypes for the X\+M\+E\+G\+A Self-\/programming driver. If any S\+P\+M instructions are used, the linker file must define a segment named B\+O\+O\+T which must be located in the device boot section.

\begin{DoxyVerb} None of these functions clean up the NVM Command Register after use.
 It is therefore important to write NVMCMD_NO_OPERATION (0x00) to this
 register when you are finished using any of the functions in this driver.

 For all functions, it is important that no interrupt handlers
 perform any NVM operations. The user must implement a scheme for mutually
 exclusive access to the NVM. However, the 4-cycle timeout will work fine,
 since writing to the Configuration Change Protection register (CCP)
 automatically disables interrupts for 4 instruction cycles.
\end{DoxyVerb}


\begin{DoxyParagraph}{Application note\+:}
A\+V\+R1316\+: X\+M\+E\+G\+A Self-\/programming
\end{DoxyParagraph}
\begin{DoxyParagraph}{Documentation}
For comprehensive code documentation, supported compilers, compiler settings and supported devices see readme.\+html
\end{DoxyParagraph}
\begin{DoxyAuthor}{Author}
Atmel Corporation\+: \href{http://www.atmel.com}{\tt http\+://www.\+atmel.\+com} ~\newline
 Support email\+: \href{mailto:avr@atmel.com}{\tt avr@atmel.\+com}
\end{DoxyAuthor}
\begin{DoxyParagraph}{Revision}
1691 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Date}
2008-\/07-\/29 13\+:25\+:40 +0200 (ti, 29 jul 2008) 
\end{DoxyParagraph}
~\newline
 Copyright (c) 2008, Atmel Corporation All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met\+:


\begin{DoxyEnumerate}
\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
\item The name of A\+T\+M\+E\+L may not be used to endorse or promote products derived from this software without specific prior written permission.
\end{DoxyEnumerate}

T\+H\+I\+S S\+O\+F\+T\+W\+A\+R\+E I\+S P\+R\+O\+V\+I\+D\+E\+D B\+Y A\+T\+M\+E\+L \char`\"{}\+A\+S I\+S\char`\"{} A\+N\+D A\+N\+Y E\+X\+P\+R\+E\+S\+S O\+R I\+M\+P\+L\+I\+E\+D W\+A\+R\+R\+A\+N\+T\+I\+E\+S, I\+N\+C\+L\+U\+D\+I\+N\+G, B\+U\+T N\+O\+T L\+I\+M\+I\+T\+E\+D T\+O, T\+H\+E I\+M\+P\+L\+I\+E\+D W\+A\+R\+R\+A\+N\+T\+I\+E\+S O\+F M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+T\+Y A\+N\+D F\+I\+T\+N\+E\+S\+S F\+O\+R A P\+A\+R\+T\+I\+C\+U\+L\+A\+R P\+U\+R\+P\+O\+S\+E A\+R\+E E\+X\+P\+R\+E\+S\+S\+L\+Y A\+N\+D S\+P\+E\+C\+I\+F\+I\+C\+A\+L\+L\+Y D\+I\+S\+C\+L\+A\+I\+M\+E\+D. I\+N N\+O E\+V\+E\+N\+T S\+H\+A\+L\+L A\+T\+M\+E\+L B\+E L\+I\+A\+B\+L\+E F\+O\+R A\+N\+Y D\+I\+R\+E\+C\+T, I\+N\+D\+I\+R\+E\+C\+T, I\+N\+C\+I\+D\+E\+N\+T\+A\+L, S\+P\+E\+C\+I\+A\+L, E\+X\+E\+M\+P\+L\+A\+R\+Y, O\+R C\+O\+N\+S\+E\+Q\+U\+E\+N\+T\+I\+A\+L D\+A\+M\+A\+G\+E\+S (I\+N\+C\+L\+U\+D\+I\+N\+G, B\+U\+T N\+O\+T L\+I\+M\+I\+T\+E\+D T\+O, P\+R\+O\+C\+U\+R\+E\+M\+E\+N\+T O\+F S\+U\+B\+S\+T\+I\+T\+U\+T\+E G\+O\+O\+D\+S O\+R S\+E\+R\+V\+I\+C\+E\+S; L\+O\+S\+S O\+F U\+S\+E, D\+A\+T\+A, O\+R P\+R\+O\+F\+I\+T\+S; O\+R B\+U\+S\+I\+N\+E\+S\+S I\+N\+T\+E\+R\+R\+U\+P\+T\+I\+O\+N) H\+O\+W\+E\+V\+E\+R C\+A\+U\+S\+E\+D A\+N\+D O\+N A\+N\+Y T\+H\+E\+O\+R\+Y O\+F L\+I\+A\+B\+I\+L\+I\+T\+Y, W\+H\+E\+T\+H\+E\+R I\+N C\+O\+N\+T\+R\+A\+C\+T, S\+T\+R\+I\+C\+T L\+I\+A\+B\+I\+L\+I\+T\+Y, O\+R T\+O\+R\+T (I\+N\+C\+L\+U\+D\+I\+N\+G N\+E\+G\+L\+I\+G\+E\+N\+C\+E O\+R O\+T\+H\+E\+R\+W\+I\+S\+E) A\+R\+I\+S\+I\+N\+G I\+N A\+N\+Y W\+A\+Y O\+U\+T O\+F T\+H\+E U\+S\+E O\+F T\+H\+I\+S S\+O\+F\+T\+W\+A\+R\+E, E\+V\+E\+N I\+F A\+D\+V\+I\+S\+E\+D O\+F T\+H\+E P\+O\+S\+S\+I\+B\+I\+L\+I\+T\+Y O\+F S\+U\+C\+H D\+A\+M\+A\+G\+E. 

Definition in file \hyperlink{sp__driver_8h_source}{sp\+\_\+driver.\+h}.



\subsection{Function Documentation}
\hypertarget{sp__driver_8h_a00e556f84f34b0406599d7d8fd5c1953}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Application\+C\+R\+C@{S\+P\+\_\+\+Application\+C\+R\+C}}
\index{S\+P\+\_\+\+Application\+C\+R\+C@{S\+P\+\_\+\+Application\+C\+R\+C}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Application\+C\+R\+C}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t S\+P\+\_\+\+Application\+C\+R\+C (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a00e556f84f34b0406599d7d8fd5c1953}


Generate C\+R\+C from application section. 


\begin{DoxyRetVals}{Return values}
{\em 24-\/bit} & C\+R\+C value \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_a426f0237e39b43bb8e59412496d14cbb}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Boot\+C\+R\+C@{S\+P\+\_\+\+Boot\+C\+R\+C}}
\index{S\+P\+\_\+\+Boot\+C\+R\+C@{S\+P\+\_\+\+Boot\+C\+R\+C}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Boot\+C\+R\+C}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t S\+P\+\_\+\+Boot\+C\+R\+C (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a426f0237e39b43bb8e59412496d14cbb}


Generate C\+R\+C from boot section. 


\begin{DoxyRetVals}{Return values}
{\em 24-\/bit} & C\+R\+C value \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_aa236da5a509d82a611c4a4ce402f812d}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Application\+Page@{S\+P\+\_\+\+Erase\+Application\+Page}}
\index{S\+P\+\_\+\+Erase\+Application\+Page@{S\+P\+\_\+\+Erase\+Application\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Application\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Application\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_aa236da5a509d82a611c4a4ce402f812d}


Erase page at byte address in application or application table section. 

This function erase one page given by the byte address.


\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a8ebac0543ec938aa54e0ec412518ea35}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Application\+Section@{S\+P\+\_\+\+Erase\+Application\+Section}}
\index{S\+P\+\_\+\+Erase\+Application\+Section@{S\+P\+\_\+\+Erase\+Application\+Section}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Application\+Section}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Application\+Section (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a8ebac0543ec938aa54e0ec412518ea35}


Erase entire application section. 

This function erases the entire application and application table section

\begin{DoxyNote}{Note}
If the lock bits is set to not allow spm in the application or application table section the erase is not done. 
\end{DoxyNote}
\hypertarget{sp__driver_8h_a871749d5045b368d9d901e51dceb8ca8}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Boot\+Page@{S\+P\+\_\+\+Erase\+Boot\+Page}}
\index{S\+P\+\_\+\+Erase\+Boot\+Page@{S\+P\+\_\+\+Erase\+Boot\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Boot\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Boot\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a871749d5045b368d9d901e51dceb8ca8}


Erase page at byte address in boot section. 

This function erase one page given by the byte address.


\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_aa74a9476a4b9f347b9daf12c2f46141f}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Flash\+Buffer@{S\+P\+\_\+\+Erase\+Flash\+Buffer}}
\index{S\+P\+\_\+\+Erase\+Flash\+Buffer@{S\+P\+\_\+\+Erase\+Flash\+Buffer}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Flash\+Buffer}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Flash\+Buffer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_aa74a9476a4b9f347b9daf12c2f46141f}


Flush Flash page buffer. 

This function flush the Flash page buffer. \hypertarget{sp__driver_8h_ac99150fdc460f2149d61bccabece890f}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+User\+Signature\+Row@{S\+P\+\_\+\+Erase\+User\+Signature\+Row}}
\index{S\+P\+\_\+\+Erase\+User\+Signature\+Row@{S\+P\+\_\+\+Erase\+User\+Signature\+Row}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+User\+Signature\+Row}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+User\+Signature\+Row (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_ac99150fdc460f2149d61bccabece890f}


Erase user signature row. 

This function erase the entire user signature row. \hypertarget{sp__driver_8h_a51aea1f2853f936d1f8b7c78f807599b}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Write\+Application\+Page@{S\+P\+\_\+\+Erase\+Write\+Application\+Page}}
\index{S\+P\+\_\+\+Erase\+Write\+Application\+Page@{S\+P\+\_\+\+Erase\+Write\+Application\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Write\+Application\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Write\+Application\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a51aea1f2853f936d1f8b7c78f807599b}


Erase and write page buffer to application or application table section at byte address. 

This function does a combined erase and write to a flash page in the application or application table section.


\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_adbb70c7a63522cbf39cfb3b9cd9afcbc}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Erase\+Write\+Boot\+Page@{S\+P\+\_\+\+Erase\+Write\+Boot\+Page}}
\index{S\+P\+\_\+\+Erase\+Write\+Boot\+Page@{S\+P\+\_\+\+Erase\+Write\+Boot\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Erase\+Write\+Boot\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Erase\+Write\+Boot\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_adbb70c7a63522cbf39cfb3b9cd9afcbc}


Erase and write page buffer to boot section at byte address. 

This function does a combined erase and write to a flash page in the boot section.


\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a6ee74fd6350479ede6fd43e8f6e907d5}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Load\+Flash\+Page@{S\+P\+\_\+\+Load\+Flash\+Page}}
\index{S\+P\+\_\+\+Load\+Flash\+Page@{S\+P\+\_\+\+Load\+Flash\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Load\+Flash\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Load\+Flash\+Page (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t $\ast$}]{data}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a6ee74fd6350479ede6fd43e8f6e907d5}


Load entire page from S\+R\+A\+M buffer into Flash page buffer. 

This function load an entire page from S\+R\+A\+M.


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to the data to put in buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The \+\_\+\+\_\+near keyword limits the pointer to two bytes which means that only data up to 64\+K (internal S\+R\+A\+M) can be used. 
\end{DoxyNote}
\hypertarget{sp__driver_8h_ae6885c758d6ab15ff642d61c410d900b}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Load\+Flash\+Word@{S\+P\+\_\+\+Load\+Flash\+Word}}
\index{S\+P\+\_\+\+Load\+Flash\+Word@{S\+P\+\_\+\+Load\+Flash\+Word}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Load\+Flash\+Word}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Load\+Flash\+Word (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{address, }
\item[{uint16\+\_\+t}]{data}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_ae6885c758d6ab15ff642d61c410d900b}


Load one word into Flash page buffer. 

This function Loads one word into the Flash page buffer.


\begin{DoxyParams}{Parameters}
{\em address} & Position in inside the flash page buffer. \\
\hline
{\em data} & Value to be put into the buffer. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a999ae14f2a363cb4bcc06a4df180d0da}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Lock\+S\+P\+M@{S\+P\+\_\+\+Lock\+S\+P\+M}}
\index{S\+P\+\_\+\+Lock\+S\+P\+M@{S\+P\+\_\+\+Lock\+S\+P\+M}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Lock\+S\+P\+M}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Lock\+S\+P\+M (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a999ae14f2a363cb4bcc06a4df180d0da}


Lock S\+P\+M instruction. 

This function locks the S\+P\+M instruction, and will disable the use of S\+P\+M until the next reset occurs. \hypertarget{sp__driver_8h_a861f2edbb59b39aecaa4e2e419848041}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Byte@{S\+P\+\_\+\+Read\+Byte}}
\index{S\+P\+\_\+\+Read\+Byte@{S\+P\+\_\+\+Read\+Byte}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Byte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t S\+P\+\_\+\+Read\+Byte (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a861f2edbb59b39aecaa4e2e419848041}


Read a byte from flash. 

This function reads one byte from the flash.

\begin{DoxyNote}{Note}
Both I\+A\+R and G\+C\+C have functions to do this, but we include the fucntions for easier use.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em address} & Address to the location of the byte to read.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Byte} & read from flash. \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_abcc2ef603c461cd65a0fd08b2d97d78c}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Calibration\+Byte@{S\+P\+\_\+\+Read\+Calibration\+Byte}}
\index{S\+P\+\_\+\+Read\+Calibration\+Byte@{S\+P\+\_\+\+Read\+Calibration\+Byte}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Calibration\+Byte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t S\+P\+\_\+\+Read\+Calibration\+Byte (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{index}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_abcc2ef603c461cd65a0fd08b2d97d78c}


Read calibration byte at given index. 

This function reads one calibration byte from the Calibration signature row.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the byte in the calibration signature row.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Calibration} & byte \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_a289939190650886f1875c31e39fefdb1}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Flash\+Page@{S\+P\+\_\+\+Read\+Flash\+Page}}
\index{S\+P\+\_\+\+Read\+Flash\+Page@{S\+P\+\_\+\+Read\+Flash\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Flash\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Read\+Flash\+Page (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t $\ast$}]{data, }
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a289939190650886f1875c31e39fefdb1}


Read entire Flash page into S\+R\+A\+M buffer. 

This function reads an entire flash page and puts it to S\+R\+A\+M.


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to where to store the data. \\
\hline
{\em address} & Address to page to read from flash. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a028b313c0219dff97ee0b8ee826ad578}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Fuse\+Byte@{S\+P\+\_\+\+Read\+Fuse\+Byte}}
\index{S\+P\+\_\+\+Read\+Fuse\+Byte@{S\+P\+\_\+\+Read\+Fuse\+Byte}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Fuse\+Byte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t S\+P\+\_\+\+Read\+Fuse\+Byte (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{index}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a028b313c0219dff97ee0b8ee826ad578}


Read fuse byte from given index. 

This function reads the fuse byte at the given index.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the fuse byte.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Fuse} & byte \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_a9b8eca47d5ffc611e4973bd6623b3c19}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Lock\+Bits@{S\+P\+\_\+\+Read\+Lock\+Bits}}
\index{S\+P\+\_\+\+Read\+Lock\+Bits@{S\+P\+\_\+\+Read\+Lock\+Bits}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Lock\+Bits}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t S\+P\+\_\+\+Read\+Lock\+Bits (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a9b8eca47d5ffc611e4973bd6623b3c19}


Read lock bits. 

This function reads the lock bits.


\begin{DoxyRetVals}{Return values}
{\em Lock} & bits \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_ab79a6d78a9af76ffa62e2dccfcc5c1b4}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+User\+Signature\+Byte@{S\+P\+\_\+\+Read\+User\+Signature\+Byte}}
\index{S\+P\+\_\+\+Read\+User\+Signature\+Byte@{S\+P\+\_\+\+Read\+User\+Signature\+Byte}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+User\+Signature\+Byte}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t S\+P\+\_\+\+Read\+User\+Signature\+Byte (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{index}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_ab79a6d78a9af76ffa62e2dccfcc5c1b4}


Read user signature at given index. 

This function reads one byte from the user signature row.


\begin{DoxyParams}{Parameters}
{\em index} & Index of the byte in the user signature row.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em User} & signature byte \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_a4dcbd30344e9245c57ba8545a949c77e}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Read\+Word@{S\+P\+\_\+\+Read\+Word}}
\index{S\+P\+\_\+\+Read\+Word@{S\+P\+\_\+\+Read\+Word}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Read\+Word}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t S\+P\+\_\+\+Read\+Word (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a4dcbd30344e9245c57ba8545a949c77e}


Read a word from flash. 

This function reads one word from the flash.

\begin{DoxyNote}{Note}
Both I\+A\+R and G\+C\+C have functions to do this automatically, but we include the fucntions for easier use.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em address} & Address to the location of the word to read.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em word} & read from flash. \\
\hline
\end{DoxyRetVals}
\hypertarget{sp__driver_8h_aa972c2c5f7d4393c945a851401c09718}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Wait\+For\+S\+P\+M@{S\+P\+\_\+\+Wait\+For\+S\+P\+M}}
\index{S\+P\+\_\+\+Wait\+For\+S\+P\+M@{S\+P\+\_\+\+Wait\+For\+S\+P\+M}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Wait\+For\+S\+P\+M}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Wait\+For\+S\+P\+M (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_aa972c2c5f7d4393c945a851401c09718}


Wait for S\+P\+M to finish. 

This routine waits for the S\+P\+M to finish and clears the command register. \hypertarget{sp__driver_8h_a73fd220e37969fe8f9000c51aee3766b}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Write\+Application\+Page@{S\+P\+\_\+\+Write\+Application\+Page}}
\index{S\+P\+\_\+\+Write\+Application\+Page@{S\+P\+\_\+\+Write\+Application\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Write\+Application\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Write\+Application\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a73fd220e37969fe8f9000c51aee3766b}


Write page buffer to application or application table section at byte address. 

This function writes the Flash page buffer to a page in the application or application table section given by the byte address.

\begin{DoxyNote}{Note}
The page that is written to must be erased before it is written to.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_afee128140615cf5639876e2efe7d8595}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Write\+Boot\+Page@{S\+P\+\_\+\+Write\+Boot\+Page}}
\index{S\+P\+\_\+\+Write\+Boot\+Page@{S\+P\+\_\+\+Write\+Boot\+Page}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Write\+Boot\+Page}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Write\+Boot\+Page (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_afee128140615cf5639876e2efe7d8595}


Write page buffer to boot section at byte address. 

This function writes the Flash page buffer to a page in the boot section given by the byte address.

\begin{DoxyNote}{Note}
The page that is written to must be erased before it is written to.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em address} & Byte address for flash page. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a70340a21824f27957af2ed59300b7a4a}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Write\+Lock\+Bits@{S\+P\+\_\+\+Write\+Lock\+Bits}}
\index{S\+P\+\_\+\+Write\+Lock\+Bits@{S\+P\+\_\+\+Write\+Lock\+Bits}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Write\+Lock\+Bits}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Write\+Lock\+Bits (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{data}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a70340a21824f27957af2ed59300b7a4a}


Write lock bits. 

This function changes the lock bits.

\begin{DoxyNote}{Note}
It is only possible to change the lock bits to a higher security level.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em data} & The new value of the lock bits. \\
\hline
\end{DoxyParams}
\hypertarget{sp__driver_8h_a660b4581eeefe19b3f0d80989abeaa39}{\index{sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}!S\+P\+\_\+\+Write\+User\+Signature\+Row@{S\+P\+\_\+\+Write\+User\+Signature\+Row}}
\index{S\+P\+\_\+\+Write\+User\+Signature\+Row@{S\+P\+\_\+\+Write\+User\+Signature\+Row}!sp\+\_\+driver.\+h@{sp\+\_\+driver.\+h}}
\subsubsection[{S\+P\+\_\+\+Write\+User\+Signature\+Row}]{\setlength{\rightskip}{0pt plus 5cm}void S\+P\+\_\+\+Write\+User\+Signature\+Row (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{sp__driver_8h_a660b4581eeefe19b3f0d80989abeaa39}


Write user signature row. 

This function write the flash buffer in the user signature row. 